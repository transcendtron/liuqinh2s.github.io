<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Liuqinh2s' Homepage</title>
    <description>专攻计算机</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 25 Jan 2017 11:16:03 +0800</pubDate>
    <lastBuildDate>Wed, 25 Jan 2017 11:16:03 +0800</lastBuildDate>
    <generator>Jekyll v3.3.1</generator>

      <item>
        <title>leetcode讲解之开篇--486. Predict the Winner</title>
        <description>&lt;h3 id=&quot;486-predict-the-winner&quot;&gt;486. Predict the Winner&lt;/h3&gt;

&lt;p&gt;Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins.&lt;/p&gt;

&lt;p&gt;Given an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score.&lt;/p&gt;

&lt;p&gt;Example 1:&lt;/p&gt;

&lt;p&gt;Input: [1, 5, 2]&lt;/p&gt;

&lt;p&gt;Output: False&lt;/p&gt;

&lt;p&gt;Explanation: Initially, player 1 can choose between 1 and 2.&lt;/p&gt;

&lt;p&gt;If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2).&lt;/p&gt;

&lt;p&gt;So, final score of player 1 is 1 + 2 = 3, and player 2 is 5.&lt;/p&gt;

&lt;p&gt;Hence, player 1 will never be the winner and you need to return False.&lt;/p&gt;

&lt;p&gt;Example 2:&lt;/p&gt;

&lt;p&gt;Input: [1, 5, 233, 7]&lt;/p&gt;

&lt;p&gt;Output: True&lt;/p&gt;

&lt;p&gt;Explanation: Player 1 first chooses 1. Then player 2 have to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.&lt;/p&gt;

&lt;p&gt;Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.&lt;/p&gt;

&lt;p&gt;Note:&lt;/p&gt;

&lt;p&gt;1 &amp;lt;= length of the array &amp;lt;= 20.&lt;/p&gt;

&lt;p&gt;Any scores in the given array are non-negative integers and will not exceed 10,000,000.&lt;/p&gt;

&lt;p&gt;If the scores of both players are equal, then player 1 is still the winner.&lt;/p&gt;

&lt;h4 id=&quot;翻译&quot;&gt;翻译&lt;/h4&gt;

&lt;p&gt;给定一个非负的整形的数组（数组中装的数称为分数）。玩家1从数组的任意一端挑走一个数，接着是玩家2，接着又是玩家1。每次一个玩家挑走一个数，这个数就不能被下一个玩家挑了。一直这样直到所有分数都被选走。拥有分数总和多的玩家获胜。&lt;/p&gt;

&lt;p&gt;给定一个包含分数的数组，预言玩家1是否会赢。你应该假设每个玩家都想要把自己的分数最大化。&lt;/p&gt;

&lt;p&gt;例子1：&lt;/p&gt;

&lt;p&gt;输入：[1, 5, 2]&lt;/p&gt;

&lt;p&gt;输出: False&lt;/p&gt;

&lt;p&gt;解释: 初始条件下, 玩家1可以在 1 和 2 之间选择。&lt;/p&gt;

&lt;p&gt;如果他选择 2 (或 1), 然后玩家2能从 1（或者 2）和 5 之间选择. 如果玩家2选择5, 然后玩家1只剩下 1 或者 2 可以选择。&lt;/p&gt;

&lt;p&gt;所以最后玩家1的分数是 3 ，玩家2的分数是 5。&lt;/p&gt;

&lt;p&gt;因此，玩家1不可能赢，你应该返回 False。&lt;/p&gt;

&lt;p&gt;例子2：&lt;/p&gt;

&lt;p&gt;输入: [1, 5, 233, 7]&lt;/p&gt;

&lt;p&gt;输出: True&lt;/p&gt;

&lt;p&gt;解释: 玩家1首先选择1. 玩家2必须在 5 和 7 之间选择. 不管玩家2选择哪个数, 玩家1总能选到233。&lt;/p&gt;

&lt;p&gt;最后玩家1（234）比玩家2（12）拥有更多的分数, 所以你应该返回True，代表玩家1会赢。&lt;/p&gt;

&lt;p&gt;注意：&lt;/p&gt;

&lt;p&gt;1 &amp;lt;= 数组的长度 &amp;lt;= 20。&lt;/p&gt;

&lt;p&gt;给定的数组中的每个分数都是非负的并且不会超过10,000,000。&lt;/p&gt;

&lt;p&gt;如果每个玩家的分数都是相等的，那么玩家1就是赢家。&lt;/p&gt;

&lt;h4 id=&quot;分析&quot;&gt;分析&lt;/h4&gt;
</description>
        <pubDate>Wed, 25 Jan 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/01/leetcode%E8%AE%B2%E8%A7%A3-486.-Predict-the-Winner/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/01/leetcode%E8%AE%B2%E8%A7%A3-486.-Predict-the-Winner/</guid>

        <category>算法</category>

        <category>leetcode</category>

        <category>编程</category>


        <category>leetcode</category>

      </item>

      <item>
        <title>leetcode讲解--378. Kth Smallest Element in a Sorted Matrix</title>
        <description>&lt;h3 id=&quot;378-kth-smallest-element-in-a-sorted-matrix&quot;&gt;378. Kth Smallest Element in a Sorted Matrix&lt;/h3&gt;

&lt;p&gt;Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.&lt;/p&gt;

&lt;p&gt;Note that it is the kth smallest element in the sorted order, not the kth distinct element.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

return 13.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note:&lt;/p&gt;

&lt;p&gt;You may assume k is always valid, 1 ≤ k ≤ n^2.&lt;/p&gt;

&lt;h4 id=&quot;翻译&quot;&gt;翻译&lt;/h4&gt;

&lt;p&gt;给定一个 n x n 的矩阵，它的行和列都是按升序排列的，找到矩阵中第k小的元素。&lt;/p&gt;

&lt;p&gt;注意：是按排序第k小的元素，不是第k个不同的元素。&lt;/p&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

return 13.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：&lt;/p&gt;

&lt;p&gt;你应该假设k总是有效的，1 ≤ k ≤ n^2。&lt;/p&gt;

&lt;h4 id=&quot;分析&quot;&gt;分析&lt;/h4&gt;

&lt;p&gt;算法题嘛，让我们先从复杂度高的算法开始逐步进化到复杂度低的吧。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;利用数据结构：堆&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先我们很容易想到，可以利用小根堆来存放所有元素，然后弹出到第k个，那就是第k小的啦。遍历一遍矩阵，复杂度：O(n^2)，弹出堆顶以及维护堆，k*log(n^2)。复杂度是有点高。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution(object):
    def kthSmallest(self, matrix, k):
        &quot;&quot;&quot;
        :type matrix: List[List[int]]
        :type k: int
        :rtype: int
        &quot;&quot;&quot;
        q = []
        for i in range(0,len(matrix)):
            for j in range(0,len(matrix[0])):
                heapq.heappush(q,matrix[i][j])
        for x in range(1,k):
            heapq.heappop(q)
        return heapq.heappop(q)
# 下面的代码用了一个库函数，哈哈
class Solution(object):
    def kthSmallest(self, matrix, k):
        &quot;&quot;&quot;
        :type matrix: List[List[int]]
        :type k: int
        :rtype: int
        &quot;&quot;&quot;
        q = []
        for i in range(0,len(matrix)):
            for j in range(0,len(matrix[0])):
                heapq.heappush(q,matrix[i][j])

        return heapq.nsmallest(k, q)[k-1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们漏了一个条件就是：行和列都是升序排列的，所以没有必要遍历一遍整个矩阵。&lt;/p&gt;

&lt;p&gt;算法：&lt;/p&gt;

&lt;p&gt;首先将矩阵的左上角（下标0,0）元素加入堆&lt;/p&gt;

&lt;p&gt;然后执行k次循环：&lt;/p&gt;

&lt;p&gt;弹出堆顶元素top，记其下标为i, j&lt;/p&gt;

&lt;p&gt;将其下方元素matrix[i + 1][j]，与右方元素matrix[i][j + 1]加入堆（若它们没有加入过堆）&lt;/p&gt;

&lt;p&gt;我们还是维护一个小根堆，不过这次我们一边加元素进堆（每次都找堆顶元素在矩阵中的下面和右边的元素入堆），一边弹出堆顶（弹k次即可哦）。复杂度：入堆是2log(n^2)，弹出堆顶并维护堆是log(n^2)，所以时间复杂度是O(log(n^2))。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution(object):
    def kthSmallest(self, matrix, k):
        &quot;&quot;&quot;
        :type matrix: List[List[int]]
        :type k: int
        :rtype: int
        &quot;&quot;&quot;
        q = [(matrix[0][0], 0, 0)]
        n = len(matrix)
        visited = [[False]*n for i in range(n)]
        for x in range(k):
            ans, i, j = heapq.heappop(q)
            if i&amp;lt;n-1 and visited[i+1][j]==False:
                visited[i+1][j]=True
                heapq.heappush(q, [matrix[i+1][j], i+1, j])
            if j&amp;lt;n-1 and visited[i][j+1]==False:
                visited[i][j+1]=True
                heapq.heappush(q, [matrix[i][j+1], i, j+1])

        return ans
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;二分查找&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;排序的东西，&lt;/p&gt;
</description>
        <pubDate>Mon, 23 Jan 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/01/leetcode%E8%AE%B2%E8%A7%A3-378.-Kth-Smallest-Element-in-a-Sorted-Matrix/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/01/leetcode%E8%AE%B2%E8%A7%A3-378.-Kth-Smallest-Element-in-a-Sorted-Matrix/</guid>

        <category>算法</category>

        <category>编程</category>

        <category>leetcode</category>


        <category>leetcode</category>

      </item>

      <item>
        <title>leetcode讲解--206. Reverse Linked List</title>
        <description>&lt;h3 id=&quot;206-reverse-linked-list&quot;&gt;206. Reverse Linked List&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/reverse-linked-list/&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Reverse a singly linked list.&lt;/p&gt;

&lt;p&gt;翻译：&lt;/p&gt;

&lt;p&gt;翻转一个单链表。&lt;/p&gt;

&lt;p&gt;好经典的题目，翻转单链表是数据结构中单链表操作的基本操作。操作方法有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用头插法（新建一个新的头结点，然后不断的从旧结点中取出结点，查到新的头结点后面）。&lt;/li&gt;
  &lt;li&gt;双指针法（一个指针用来遍历链表，一个指针用来当新的头指针）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;另外可以用迭代和递归两种做法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

# 迭代+头插法
class Solution(object):
    def reverseList(self, head):
        &quot;&quot;&quot;
        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        list = ListNode(0)
        while head:
            next = head.next
            head.next = list.next
            list.next = head
            head = next
        return list.next
# 递归+头插法
class Solution(object):
    def reverseList(self, head):
        &quot;&quot;&quot;
        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        newHead = ListNode(0)
        return self.doReverse(head, newHead)
    def doReverse(self, head, newHead):
        if head:
            next = head.next
            head.next = newHead.next
            newHead.next = head
            return self.doReverse(next, newHead)
        else:
            return newHead.next
# 迭代+双指针法
class Solution(object):
    def reverseList(self, head):
        &quot;&quot;&quot;
        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        newHead = None
        while head:
            next = head.next
            head.next = newHead
            newHead = head
            head = next
        return newHead
# 递归+双指针法
class Solution(object):
    def doReverse(self, nowNode, newHead):
        if nowNode:
            next = nowNode.next
            nowNode.next = newHead
            return self.doReverse(next, nowNode)
        else:
            return newHead
    def reverseList(self, head):
        &quot;&quot;&quot;
        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        return self.doReverse(head, None)
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sun, 22 Jan 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/01/leetcode%E8%AE%B2%E8%A7%A3-206.-Reverse-Linked-List/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/01/leetcode%E8%AE%B2%E8%A7%A3-206.-Reverse-Linked-List/</guid>

        <category>算法</category>

        <category>编程</category>

        <category>leetcode</category>


        <category>leetcode</category>

      </item>

      <item>
        <title>XML教程</title>
        <description>&lt;p&gt;XML(EXtensible Markup Language，可扩展标记语言)。&lt;/p&gt;

&lt;h2 id=&quot;概念&quot;&gt;概念&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;XML 被设计用来传输和存储数据。&lt;/li&gt;
  &lt;li&gt;HTML 被设计用来显示数据。&lt;/li&gt;
  &lt;li&gt;XML &lt;strong&gt;标签没有被预定义&lt;/strong&gt;。您需要自行定义标签。&lt;/li&gt;
  &lt;li&gt;XML 被设计为具有自我描述性。&lt;/li&gt;
  &lt;li&gt;XML 元素是可扩展的&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;XML与HTML的主要区别：&lt;/p&gt;

&lt;p&gt;XML 不是 HTML 的替代。&lt;/p&gt;

&lt;p&gt;XML 和 HTML 为不同的目的而设计：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;XML 被设计为传输和存储数据，其焦点是 &lt;strong&gt;数据的内容&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;HTML 被设计用来显示数据，其焦点是 &lt;strong&gt;数据的外观&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;HTML 旨在 &lt;strong&gt;显示信息&lt;/strong&gt;，而 XML 旨在 &lt;strong&gt;传输信息&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;xml验证器&quot;&gt;XML验证器&lt;/h3&gt;

&lt;p&gt;和任何语言一样，XML被错误的书写了，就会导致程序出错。所以我们可以使用XML验证器对XML文档进行语法校验。&lt;/p&gt;

&lt;h3 id=&quot;xml的数据是树状的&quot;&gt;XML的数据是树状的&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;bookstore&amp;gt;
&amp;lt;book category=&quot;COOKING&quot;&amp;gt;
  &amp;lt;title lang=&quot;en&quot;&amp;gt;Everyday Italian&amp;lt;/title&amp;gt;
  &amp;lt;author&amp;gt;Giada De Laurentiis&amp;lt;/author&amp;gt;
  &amp;lt;year&amp;gt;2005&amp;lt;/year&amp;gt;
  &amp;lt;price&amp;gt;30.00&amp;lt;/price&amp;gt;
&amp;lt;/book&amp;gt;
&amp;lt;book category=&quot;CHILDREN&quot;&amp;gt;
  &amp;lt;title lang=&quot;en&quot;&amp;gt;Harry Potter&amp;lt;/title&amp;gt;
  &amp;lt;author&amp;gt;J K. Rowling&amp;lt;/author&amp;gt;
  &amp;lt;year&amp;gt;2005&amp;lt;/year&amp;gt;
  &amp;lt;price&amp;gt;29.99&amp;lt;/price&amp;gt;
&amp;lt;/book&amp;gt;
&amp;lt;book category=&quot;WEB&quot;&amp;gt;
  &amp;lt;title lang=&quot;en&quot;&amp;gt;Learning XML&amp;lt;/title&amp;gt;
  &amp;lt;author&amp;gt;Erik T. Ray&amp;lt;/author&amp;gt;
  &amp;lt;year&amp;gt;2003&amp;lt;/year&amp;gt;
  &amp;lt;price&amp;gt;39.95&amp;lt;/price&amp;gt;
&amp;lt;/book&amp;gt;
&amp;lt;/bookstore&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;语法&quot;&gt;语法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;所有 XML 元素都须有关闭标签&lt;/li&gt;
  &lt;li&gt;XML 标签对大小写敏感&lt;/li&gt;
  &lt;li&gt;XML 必须正确地嵌套&lt;/li&gt;
  &lt;li&gt;XML 文档必须有根元素&lt;/li&gt;
  &lt;li&gt;XML 的属性值须加引号&lt;/li&gt;
  &lt;li&gt;实体引用（应对保留字符）&lt;/li&gt;
  &lt;li&gt;XML 中编写注释的语法与 HTML 的语法一致&lt;code&gt;&amp;lt;!-- This is a comment --&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在 XML 中，空格会被保留&lt;/li&gt;
  &lt;li&gt;XML 以 LF 存储换行&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;在 Windows 应用程序中，换行通常以一对字符来存储：回车符 (CR) 和换行符 (LF)。这对字符与打字机设置新行的动作有相似之处。在 Unix 应用程序中，新行以 LF 字符存储。而 Macintosh 应用程序使用 CR 来存储新行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在 XML 中，有 5 个预定义的实体引用：&lt;/p&gt;

&lt;table class=&quot;dataintable&quot;&gt;
&lt;tr&gt;
&lt;td&gt;&amp;amp;lt;&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;小于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;amp;gt;&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;大于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;amp;amp;&lt;/td&gt;
&lt;td&gt;&amp;amp;&lt;/td&gt;
&lt;td&gt;和号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;amp;apos;&lt;/td&gt;
&lt;td&gt;'&lt;/td&gt;
&lt;td&gt;单引号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;amp;quot;&lt;/td&gt;
&lt;td&gt;&amp;quot;&lt;/td&gt;
&lt;td&gt;引号&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;h3 id=&quot;变量命名&quot;&gt;变量命名&lt;/h3&gt;

&lt;p&gt;XML 元素必须遵循以下命名规则：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;名称可以含字母、数字以及其他的字符&lt;/li&gt;
  &lt;li&gt;名称不能以数字或者标点符号开始&lt;/li&gt;
  &lt;li&gt;名称不能以字符 “xml”（或者 XML、Xml）开始&lt;/li&gt;
  &lt;li&gt;名称不能包含空格&lt;/li&gt;
  &lt;li&gt;可使用任何名称，没有保留的字词。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最佳命名习惯&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使名称具有描述性。使用下划线的名称也很不错。
名称应当比较简短，比如：&lt;code&gt;&amp;lt;book_title&amp;gt;&lt;/code&gt;，而不是：&lt;code&gt;&amp;lt;the_title_of_the_book&amp;gt;&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;避免 “-“ 字符。如果您按照这样的方式进行命名：”first-name”，一些软件会认为你需要提取第一个单词。&lt;/li&gt;
  &lt;li&gt;避免 “.” 字符。如果您按照这样的方式进行命名：”first.name”，一些软件会认为 “name” 是对象 “first” 的属性。&lt;/li&gt;
  &lt;li&gt;避免 “:” 字符。冒号会被转换为命名空间来使用（稍后介绍）。&lt;/li&gt;
  &lt;li&gt;XML 文档经常有一个对应的数据库，其中的字段会对应 XML 文档中的元素。有一个实用的经验，即使用数据库的名称规则来命名 XML 文档中的元素。&lt;/li&gt;
  &lt;li&gt;非英语的字母比如 éòá 也是合法的 XML 元素名，不过需要留意当软件开发商不支持这些字符时可能出现的问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;xml-元素-vs-属性&quot;&gt;XML 元素 vs. 属性&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;person sex=&quot;female&quot;&amp;gt;
  &amp;lt;firstname&amp;gt;Anna&amp;lt;/firstname&amp;gt;
  &amp;lt;lastname&amp;gt;Smith&amp;lt;/lastname&amp;gt;
&amp;lt;/person&amp;gt;

&amp;lt;person&amp;gt;
  &amp;lt;sex&amp;gt;female&amp;lt;/sex&amp;gt;
  &amp;lt;firstname&amp;gt;Anna&amp;lt;/firstname&amp;gt;
  &amp;lt;lastname&amp;gt;Smith&amp;lt;/lastname&amp;gt;
&amp;lt;/person&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;没有什么规矩可以告诉我们什么时候该使用属性，而什么时候该使用子元素。我的经验是在 HTML 中，属性用起来很便利，但是在 XML 中，您应该尽量避免使用属性。如果信息感觉起来很像数据，那么请使用子元素吧。&lt;/p&gt;

&lt;p&gt;因使用属性而引起的一些问题：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;属性无法包含多重的值（元素可以）&lt;/li&gt;
  &lt;li&gt;属性无法描述树结构（元素可以）&lt;/li&gt;
  &lt;li&gt;属性不易扩展（为未来的变化）&lt;/li&gt;
  &lt;li&gt;属性难以阅读和维护&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;请尽量使用元素来描述数据。而仅仅使用属性来提供与数据无关的信息。
不要做这样的蠢事（这不是 XML 应该被使用的方式）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;note day=&quot;08&quot; month=&quot;08&quot; year=&quot;2008&quot;
to=&quot;George&quot; from=&quot;John&quot; heading=&quot;Reminder&quot;
body=&quot;Don't forget the meeting!&quot;&amp;gt;
&amp;lt;/note&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的 ID 仅仅是一个标识符，用于标识不同的便签。它并不是便签数据的组成部分。
在此我们极力向您传递的理念是：&lt;strong&gt;元数据（有关数据的数据）应当存储为属性，而数据本身应当存储为元素&lt;/strong&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;messages&amp;gt;
  &amp;lt;note id=&quot;501&quot;&amp;gt;
    &amp;lt;to&amp;gt;George&amp;lt;/to&amp;gt;
    &amp;lt;from&amp;gt;John&amp;lt;/from&amp;gt;
    &amp;lt;heading&amp;gt;Reminder&amp;lt;/heading&amp;gt;
    &amp;lt;body&amp;gt;Don't forget the meeting!&amp;lt;/body&amp;gt;
  &amp;lt;/note&amp;gt;
  &amp;lt;note id=&quot;502&quot;&amp;gt;
    &amp;lt;to&amp;gt;John&amp;lt;/to&amp;gt;
    &amp;lt;from&amp;gt;George&amp;lt;/from&amp;gt;
    &amp;lt;heading&amp;gt;Re: Reminder&amp;lt;/heading&amp;gt;
    &amp;lt;body&amp;gt;I will not&amp;lt;/body&amp;gt;
  &amp;lt;/note&amp;gt;
&amp;lt;/messages&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;xslt&quot;&gt;XSLT&lt;/h3&gt;

&lt;p&gt;EXtensible Stylesheet Language Transformations&lt;/p&gt;

&lt;p&gt;XSLT 是首选的 XML 样式表语言。&lt;/p&gt;
</description>
        <pubDate>Sat, 21 Jan 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/01/XML%E6%95%99%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/01/XML%E6%95%99%E7%A8%8B/</guid>

        <category>工具</category>

        <category>XML</category>


        <category>教程</category>

      </item>

      <item>
        <title>正则表达式</title>
        <description>&lt;p&gt;正则表达式（英文：Regular Expression）具体介绍见下面维基百科。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;维基百科词条&lt;/strong&gt;：https://en.wikipedia.org/wiki/Regular_expression
（tips：维基百科有语言选择，你可以选择中文进行阅读，前提是该词条有中文版）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;正则表达式30分钟入门教程&lt;/strong&gt;：http://deerchao.net/tutorials/regex/regex.htm&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;正则表达式测试器&lt;/strong&gt;：http://deerchao.net/tools/regex_tester/index.htm&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;常用正则表达式&lt;/strong&gt;：http://deerchao.net/tutorials/regex/common.htm&lt;/p&gt;

&lt;h1 id=&quot;基本语法&quot;&gt;基本语法&lt;/h1&gt;

&lt;h2 id=&quot;选择&quot;&gt;选择&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;|竖直分隔符代表选择&lt;/strong&gt;。例如“gray|grey”可以匹配grey或gray。&lt;/p&gt;

&lt;h2 id=&quot;数量限定&quot;&gt;数量限定&lt;/h2&gt;

&lt;p&gt;某个字符后的数量限定符用来限定前面这个字符允许出现的个数。最常见的数量限定符包括“+”、“?”和“*”（不加数量限定则代表出现一次且仅出现一次）：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;+加号代表前面的字符必须至少出现一次&lt;/strong&gt;。（1次、或多次）。例如，“goo+gle”可以匹配google、gooogle、goooogle等;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;?问号代表前面的字符最多只可以出现一次&lt;/strong&gt;。（0次、或1次）。例如，“colou?r”可以匹配color或者colour;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;*星号代表前面的字符可以不出现，也可以出现一次或者多次&lt;/strong&gt;。（0次、或1次、或多次）。例如，“0*42”可以匹配42、042、0042、00042等。&lt;/p&gt;

&lt;h2 id=&quot;匹配范围&quot;&gt;匹配范围&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;圆括号可以用来定义操作符的范围和优先度&lt;/strong&gt;。例如，“gr(a|e)y”等价于“gray|grey”，“(grand)?father”匹配father和grandfather。&lt;/p&gt;

&lt;p&gt;上述这些构造子都可以自由组合，因此，“H(ae?|ä)ndel”和“H(a|ae|ä)ndel”是相同的。&lt;/p&gt;

&lt;p&gt;精确的语法可能因不同的工具或程序而异。&lt;/p&gt;

&lt;h1 id=&quot;表达式全集&quot;&gt;表达式全集&lt;/h1&gt;

&lt;p&gt;正则表达式有多种不同的风格。下表是在 &lt;strong&gt;PCRE&lt;/strong&gt; 中元字符及其在正则表达式上下文中的行为的一个完整列表，&lt;strong&gt;适用于Perl或者Python编程语言&lt;/strong&gt;（grep或者egrep的正则表达式文法是PCRE的子集）：&lt;/p&gt;

&lt;table class=&quot;wikitable&quot;&gt;
&lt;tr&gt;
&lt;th&gt;字符&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;\&lt;/th&gt;
&lt;td&gt;将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，「&lt;code&gt;n&lt;/code&gt;」匹配字符「&lt;code&gt;n&lt;/code&gt;」。「&lt;code&gt;\n&lt;/code&gt;」匹配一个换行符。序列「&lt;code&gt;\\&lt;/code&gt;」匹配「&lt;code&gt;\&lt;/code&gt;」而「&lt;code&gt;\(&lt;/code&gt;」则匹配「&lt;code&gt;(&lt;/code&gt;」。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;^&lt;/th&gt;
&lt;td&gt;匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配「&lt;code&gt;\n&lt;/code&gt;」或「&lt;code&gt;\r&lt;/code&gt;」之后的位置。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;$&lt;/th&gt;
&lt;td&gt;匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配「&lt;code&gt;\n&lt;/code&gt;」或「&lt;code&gt;\r&lt;/code&gt;」之前的位置。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;* &lt;/th&gt;
&lt;td&gt;匹配前面的子表达式零次或多次。例如，zo*能匹配「&lt;code&gt;z&lt;/code&gt;」、「&lt;code&gt;zo&lt;/code&gt;」以及「&lt;code&gt;zoo&lt;/code&gt;」。* 等价于{0,}。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;+&lt;/th&gt;
&lt;td&gt;匹配前面的子表达式一次或多次。例如，「&lt;code&gt;zo+&lt;/code&gt;」能匹配「&lt;code&gt;zo&lt;/code&gt;」以及「&lt;code&gt;zoo&lt;/code&gt;」，但不能匹配「&lt;code&gt;z&lt;/code&gt;」。+等价于{1,}。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;?&lt;/th&gt;
&lt;td&gt;匹配前面的子表达式零次或一次。例如，「&lt;code&gt;do(es)?&lt;/code&gt;」可以匹配「&lt;code&gt;do&lt;/code&gt;」或「&lt;code&gt;does&lt;/code&gt;」中的「&lt;code&gt;do&lt;/code&gt;」。?等价于{0,1}。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;{&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;n&lt;/span&gt;}&lt;/th&gt;
&lt;td&gt;&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;n&lt;/span&gt;是一个非负整数。匹配确定的&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;n&lt;/span&gt;次。例如，「&lt;code&gt;o{2}&lt;/code&gt;」不能匹配「&lt;code&gt;Bob&lt;/code&gt;」中的「&lt;code&gt;o&lt;/code&gt;」，但是能匹配「&lt;code&gt;food&lt;/code&gt;」中的两个o。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;{&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;n&lt;/span&gt;,}&lt;/th&gt;
&lt;td&gt;&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;n&lt;/span&gt;是一个非负整数。至少匹配&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;n&lt;/span&gt;次。例如，「&lt;code&gt;o{2,}&lt;/code&gt;」不能匹配「&lt;code&gt;Bob&lt;/code&gt;」中的「&lt;code&gt;o&lt;/code&gt;」，但能匹配「&lt;code&gt;foooood&lt;/code&gt;」中的所有o。「&lt;code&gt;o{1,}&lt;/code&gt;」等价于「&lt;code&gt;o+&lt;/code&gt;」。「&lt;code&gt;o{0,}&lt;/code&gt;」则等价于「&lt;code&gt;o*&lt;/code&gt;」。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;{&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;n&lt;/span&gt;,&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;m&lt;/span&gt;}&lt;/th&gt;
&lt;td&gt;&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;m&lt;/span&gt;和&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;n&lt;/span&gt;均为非负整数，其中&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;n&lt;/span&gt;&amp;lt;=&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;m&lt;/span&gt;。最少匹配&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;n&lt;/span&gt;次且最多匹配&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;m&lt;/span&gt;次。例如，「&lt;code&gt;o{1,3}&lt;/code&gt;」将匹配「&lt;code&gt;fooooood&lt;/code&gt;」中的前三个o。「&lt;code&gt;o{0,1}&lt;/code&gt;」等价于「&lt;code&gt;o?&lt;/code&gt;」。请注意在逗号和两个数之间不能有空格。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;?&lt;/th&gt;
&lt;td&gt;当该字符紧跟在任何一个其他限制符（* ,+,?，{&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;n&lt;/span&gt;}，{&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;n&lt;/span&gt;,}，{&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;n&lt;/span&gt;,&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;m&lt;/span&gt;}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串「&lt;code&gt;oooo&lt;/code&gt;」，「&lt;code&gt;o+?&lt;/code&gt;」将匹配单个「&lt;code&gt;o&lt;/code&gt;」，而「&lt;code&gt;o+&lt;/code&gt;」将匹配所有「&lt;code&gt;o&lt;/code&gt;」。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;.&lt;/th&gt;
&lt;td&gt;匹配除「&lt;code&gt;\n&lt;/code&gt;」之外的任何单个字符。要匹配包括「&lt;code&gt;\n&lt;/code&gt;」在内的任何字符，请使用像「&lt;code&gt;(.|\n)&lt;/code&gt;」的模式。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;(pattern)&lt;/th&gt;
&lt;td&gt;匹配pattern并获取这一匹配的子字符串。该子字符串用于向后引用。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括號字符，请使用「&lt;code&gt;\(&lt;/code&gt;」或「&lt;code&gt;\)&lt;/code&gt;」。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;(?:pattern)&lt;/th&gt;
&lt;td&gt;匹配pattern但不获取匹配的子字符串，也就是说这是一个非获取匹配，不存储匹配的子字符串用于向后引用。这在使用或字符「&lt;code&gt;(|)&lt;/code&gt;」来组合一个模式的各个部分是很有用。例如「&lt;code&gt;industr(?:y|ies)&lt;/code&gt;」就是一个比「&lt;code&gt;industry|industries&lt;/code&gt;」更简略的表达式。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;(?=pattern)&lt;/th&gt;
&lt;td&gt;正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，「&lt;code&gt;Windows(?=95|98|NT|2000)&lt;/code&gt;」能匹配「&lt;code&gt;Windows2000&lt;/code&gt;」中的「&lt;code&gt;Windows&lt;/code&gt;」，但不能匹配「&lt;code&gt;Windows3.1&lt;/code&gt;」中的「&lt;code&gt;Windows&lt;/code&gt;」。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;(?!pattern)&lt;/th&gt;
&lt;td&gt;正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如「&lt;code&gt;Windows(?!95|98|NT|2000)&lt;/code&gt;」能匹配「&lt;code&gt;Windows3.1&lt;/code&gt;」中的「&lt;code&gt;Windows&lt;/code&gt;」，但不能匹配「&lt;code&gt;Windows2000&lt;/code&gt;」中的「&lt;code&gt;Windows&lt;/code&gt;」。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;(?&amp;lt;=pattern)&lt;/th&gt;
&lt;td&gt;反向肯定预查，与正向肯定预查类似，只是方向相反。例如，「&lt;code&gt;(?&amp;lt;=95|98|NT|2000)Windows&lt;/code&gt;」能匹配「&lt;code&gt;2000Windows&lt;/code&gt;」中的「&lt;code&gt;Windows&lt;/code&gt;」，但不能匹配「&lt;code&gt;3.1Windows&lt;/code&gt;」中的「&lt;code&gt;Windows&lt;/code&gt;」。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;(?&amp;lt;!pattern)&lt;/th&gt;
&lt;td&gt;反向否定预查，与正向否定预查类似，只是方向相反。例如「&lt;code&gt;(?&amp;lt;!95|98|NT|2000)Windows&lt;/code&gt;」能匹配「&lt;code&gt;3.1Windows&lt;/code&gt;」中的「&lt;code&gt;Windows&lt;/code&gt;」，但不能匹配「&lt;code&gt;2000Windows&lt;/code&gt;」中的「&lt;code&gt;Windows&lt;/code&gt;」。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;x|y&lt;/th&gt;
&lt;td&gt;匹配x或y。例如，「&lt;code&gt;z|food&lt;/code&gt;」能匹配「&lt;code&gt;z&lt;/code&gt;」或「&lt;code&gt;food&lt;/code&gt;」。「&lt;code&gt;(?:z|f)ood&lt;/code&gt;」则匹配「&lt;code&gt;zood&lt;/code&gt;」或「&lt;code&gt;food&lt;/code&gt;」。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;[xyz]&lt;/th&gt;
&lt;td&gt;字符集合（character class）。匹配所包含的任意一个字符。例如，「&lt;code&gt;[abc]&lt;/code&gt;」可以匹配「&lt;code&gt;plain&lt;/code&gt;」中的「&lt;code&gt;a&lt;/code&gt;」。特殊字符仅有反斜线\保持特殊含义，用于转义字符。其它特殊字符如星号、加号、各种括号等均作为普通字符。脱字符^如果出现在首位则表示负值字符集合；如果出现在字符串中间就仅作为普通字符。连字符 - 如果出现在字符串中间表示字符范围描述；如果如果出现在首位则仅作为普通字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;[^xyz]&lt;/th&gt;
&lt;td&gt;排除型（negate）字符集合。匹配未列出的任意字符。例如，「&lt;code&gt;[^abc]&lt;/code&gt;」可以匹配「&lt;code&gt;plain&lt;/code&gt;」中的「&lt;code&gt;plin&lt;/code&gt;」。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;[a-z]&lt;/th&gt;
&lt;td&gt;字符范围。匹配指定范围内的任意字符。例如，「&lt;code&gt;[a-z]&lt;/code&gt;」可以匹配「&lt;code&gt;a&lt;/code&gt;」到「&lt;code&gt;z&lt;/code&gt;」范围内的任意小写字母字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;[^a-z]&lt;/th&gt;
&lt;td&gt;排除型的字符范围。匹配任何不在指定范围内的任意字符。例如，「&lt;code&gt;[^a-z]&lt;/code&gt;」可以匹配任何不在「&lt;code&gt;a&lt;/code&gt;」到「&lt;code&gt;z&lt;/code&gt;」范围内的任意字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;\b&lt;/th&gt;
&lt;td&gt;匹配一个单词边界，也就是指单词和空格间的位置。例如，「&lt;code&gt;er\b&lt;/code&gt;」可以匹配「&lt;code&gt;never&lt;/code&gt;」中的「&lt;code&gt;er&lt;/code&gt;」，但不能匹配「&lt;code&gt;verb&lt;/code&gt;」中的「&lt;code&gt;er&lt;/code&gt;」。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;\B&lt;/th&gt;
&lt;td&gt;匹配非单词边界。「&lt;code&gt;er\B&lt;/code&gt;」能匹配「&lt;code&gt;verb&lt;/code&gt;」中的「&lt;code&gt;er&lt;/code&gt;」，但不能匹配「&lt;code&gt;never&lt;/code&gt;」中的「&lt;code&gt;er&lt;/code&gt;」。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;\cx&lt;/th&gt;
&lt;td&gt;匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的「&lt;code&gt;c&lt;/code&gt;」字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;\d&lt;/th&gt;
&lt;td&gt;匹配一个数字字符。等价于[0-9]。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;\D&lt;/th&gt;
&lt;td&gt;匹配一个非数字字符。等价于[^0-9]。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;\f&lt;/th&gt;
&lt;td&gt;匹配一个换页符。等价于\x0c和\cL。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;\n&lt;/th&gt;
&lt;td&gt;匹配一个换行符。等价于\x0a和\cJ。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;\r&lt;/th&gt;
&lt;td&gt;匹配一个回车符。等价于\x0d和\cM。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;\s&lt;/th&gt;
&lt;td&gt;匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;\S&lt;/th&gt;
&lt;td&gt;匹配任何非空白字符。等价于[^ \f\n\r\t\v]。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;\t&lt;/th&gt;
&lt;td&gt;匹配一个制表符。等价于\x09和\cI。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;\v&lt;/th&gt;
&lt;td&gt;匹配一个垂直制表符。等价于\x0b和\cK。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;\w&lt;/th&gt;
&lt;td&gt;匹配包括下划线的任何单词字符。等价于「&lt;code&gt;[A-Za-z0-9_]&lt;/code&gt;」。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;\W&lt;/th&gt;
&lt;td&gt;匹配任何非单词字符。等价于「&lt;code&gt;[^A-Za-z0-9_]&lt;/code&gt;」。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;\x&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;n&lt;/span&gt;&lt;/th&gt;
&lt;td&gt;匹配&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;n&lt;/span&gt;，其中&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;n&lt;/span&gt;为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，「&lt;code&gt;\x41&lt;/code&gt;」匹配「&lt;code&gt;A&lt;/code&gt;」。「&lt;code&gt;\x041&lt;/code&gt;」则等价于「&lt;code&gt;\x04&amp;amp;1&lt;/code&gt;」。正則表达式中可以使用ASCII编码。.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;\&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;num&lt;/span&gt;&lt;/th&gt;
&lt;td&gt;向后引用（back-reference）一个子字符串（substring），该子字符串与正则表达式的第num个用括号围起来的子表达式（subexpression）匹配。其中num是从1开始的正整数，其上限可能是99。例如：「&lt;code&gt;(.)\1&lt;/code&gt;」匹配两个连续的相同字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;\&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;n&lt;/span&gt;&lt;/th&gt;
&lt;td&gt;标识一个八进制转义值或一个向后引用。如果\&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;n&lt;/span&gt;之前至少&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;n&lt;/span&gt;个获取的子表达式，则&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;n&lt;/span&gt;为向后引用。否则，如果&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;n&lt;/span&gt;为八进制数字（0-7），则&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;n&lt;/span&gt;为一个八进制转义值。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;\&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;nm&lt;/span&gt;&lt;/th&gt;
&lt;td&gt;标识一个八进制转义值或一个向后引用。如果\&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;nm&lt;/span&gt;之前至少有&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;nm&lt;/span&gt;个获得子表达式，则&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;nm&lt;/span&gt;为向后引用。如果\&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;nm&lt;/span&gt;之前至少有&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;n&lt;/span&gt;个获取，则&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;n&lt;/span&gt;为一个后跟文字&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;m&lt;/span&gt;的向后引用。如果前面的条件都不满足，若&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;n&lt;/span&gt;和&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;m&lt;/span&gt;均为八进制数字（0-7），则\&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;nm&lt;/span&gt;将匹配八进制转义值&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;nm&lt;/span&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;\&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;nml&lt;/span&gt;&lt;/th&gt;
&lt;td&gt;如果&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;n&lt;/span&gt;为八进制数字（0-3），且&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;m和l&lt;/span&gt;均为八进制数字（0-7），则匹配八进制转义值&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;nm&lt;/span&gt;l。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;\u&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;n&lt;/span&gt;&lt;/th&gt;
&lt;td&gt;匹配&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;n&lt;/span&gt;，其中&lt;span style=&quot;font-family:Times New Roman; font-style:italic;&quot;&gt;n&lt;/span&gt;是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（©）。&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;h1 id=&quot;优先权&quot;&gt;优先权&lt;/h1&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;优先权&lt;/th&gt;
      &lt;th&gt;符号&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;最高&lt;/td&gt;
      &lt;td&gt;\&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;高&lt;/td&gt;
      &lt;td&gt;()、(?:)、(?=)、[]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;中&lt;/td&gt;
      &lt;td&gt;*、+、?、{n}、{n,}、{m,n}&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;低&lt;/td&gt;
      &lt;td&gt;^、$、中介字符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;最低&lt;/td&gt;
      &lt;td&gt;|&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
        <pubDate>Fri, 20 Jan 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/01/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/01/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>

        <category>工具</category>

        <category>正则表达式</category>


        <category>教程</category>

      </item>

      <item>
        <title>markdown语法</title>
        <description>&lt;p&gt;#相关教程
&lt;a href=&quot;https://www.zybuluo.com/mdeditor?url=https%3A%2F%2Fwww.zybuluo.com%2Fstatic%2Feditor%2Fmd-help.markdown&quot;&gt;Cmd Markdown 高阶语法手册 - 作业部落&lt;/a&gt;
&lt;a href=&quot;https://coding.net/help/doc/project/markdown.html&quot;&gt;Markdown语法介绍 - Coding&lt;/a&gt;
&lt;a href=&quot;https://zh.wikipedia.org/wiki/Markdown&quot;&gt;Markdown - 维基百科，自由的百科全书&lt;/a&gt;
&lt;a href=&quot;http://wowubuntu.com/markdown/&quot;&gt;Markdown 语法说明(简体中文版) - Wow! Ubuntu&lt;/a&gt;
&lt;a href=&quot;https://github.com/riku/Markdown-Syntax-CN/blob/master/syntax.md&quot;&gt;Markdown 语法说明 (简体中文版)&lt;/a&gt;
&lt;a href=&quot;https://www.zybuluo.com/codeep/note/163962&quot;&gt;Cmd Markdown 公式指导手册&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;#语法介绍
###斜体与粗体
使用 * 和 ** 表示斜体和粗体。
示例：
这是 &lt;em&gt;斜体&lt;/em&gt;，这是 &lt;strong&gt;粗体&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;###分级标题
你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。&lt;/p&gt;

&lt;p&gt;###分割线
你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;###外链接
使用 [描述](链接地址) 为文字增加外链接。
示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[本人博客](http://liuqinh2s.com)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是去往 &lt;a href=&quot;http://teasion.github.io/blog&quot;&gt;本人博客&lt;/a&gt; 的链接。
或者你也可以这样写：（引用的写法）&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://liuqinh2s.com&quot;&gt;本人博客&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[本人博客][a link]
[a link]: http://liuqinh2s.com
//只要文本中有这一行就行，这样写是为了把链接和脚注等都放到一起（一般放在文本最后）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###插入图像
使用 ![描述](图片链接地址) 插入图像。
示例：
&lt;img src=&quot;https://ooo.0o0.ooo/2016/12/03/58429e1f4062b.png&quot; alt=&quot;myGithubAvatar.png&quot; /&gt;
或者同样采用引用的写法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;![Alt Image Text][image-id]
[image-id]: https://ooo.0o0.ooo/2016/12/03/58429e1f4062b.png &quot;Optional Title&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;![Alt Image Text][image-id]
[image-id]: https://ooo.0o0.ooo/2016/12/03/58429e1f4062b.png “Optional Title”&lt;/p&gt;

&lt;p&gt;###无序列表&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;*，+，-&lt;/code&gt; 表示无序列表。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;无序列表项 一&lt;/li&gt;
  &lt;li&gt;无序列表项 二&lt;/li&gt;
  &lt;li&gt;无序列表项 三&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;有序列表&quot;&gt;有序列表&lt;/h3&gt;
&lt;p&gt;使用数字和点表示有序列表。
示例：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;有序列表项 一&lt;/li&gt;
  &lt;li&gt;有序列表项 二&lt;/li&gt;
  &lt;li&gt;有序列表项 三&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;文字引用&quot;&gt;文字引用&lt;/h3&gt;
&lt;p&gt;使用 &amp;gt; 表示文字引用。
示例：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;野火烧不尽&lt;/p&gt;
  &lt;blockquote&gt;
    &lt;p&gt;春风吹又生&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;p&gt;白居易&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;行内代码&quot;&gt;行内代码&lt;/h3&gt;
&lt;p&gt;使用
`这里输入代码`
&lt;code&gt;eval()&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;代码块&quot;&gt;代码块&lt;/h3&gt;
&lt;p&gt;使用
```
这里输入代码
```&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;###目录
使用[toc]
[toc]&lt;/p&gt;

&lt;p&gt;###删除线
使用 ~~ 表示删除线。
&lt;del&gt;这是一段错误的文本。&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;###注脚
使用 [^keyword] 表示注脚。
这是一个注脚[^footnote1]的样例。
这是第二个注脚&lt;sup id=&quot;fnref:footnote2&quot;&gt;&lt;a href=&quot;#fn:footnote2&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;的样例。
[^footnote1]: 这是第一个&lt;/p&gt;

&lt;p&gt;###LaTex公式
$ 表示行内公式：
质能守恒方程可以用一个很简洁的方程式$\lim_{x \to 0} \sin x$来表达。
$$ 表示整行公式：
&lt;script type=&quot;math/tex&quot;&gt;\sum_{i=1}^n a_i=0&lt;/script&gt;
&lt;script type=&quot;math/tex&quot;&gt;f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2&lt;/script&gt;
&lt;script type=&quot;math/tex&quot;&gt;\sum^{j-1}_{k=0}{\widehat{\gamma}_{kj} z_k}&lt;/script&gt;
访问 &lt;a href=&quot;http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference&quot;&gt;MathJax&lt;/a&gt; 参考更多使用方法。&lt;/p&gt;

&lt;p&gt;###流程图&lt;/p&gt;
&lt;h4 id=&quot;示例&quot;&gt;示例&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-flow&quot;&gt;st=&amp;gt;start: Start:&amp;gt;https://www.zybuluo.com
io=&amp;gt;inputoutput: verification
op=&amp;gt;operation: Your Operation
cond=&amp;gt;condition: Yes or No?
sub=&amp;gt;subroutine: Your Subroutine
e=&amp;gt;end
st-&amp;gt;io-&amp;gt;op-&amp;gt;cond
cond(yes)-&amp;gt;e
cond(no)-&amp;gt;sub-&amp;gt;io
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;更多语法参考流程图语法参考&quot;&gt;更多语法参考：&lt;a href=&quot;http://adrai.github.io/flowchart.js/&quot;&gt;流程图语法参考&lt;/a&gt;&lt;/h4&gt;

&lt;h3 id=&quot;表格支持&quot;&gt;表格支持&lt;/h3&gt;
&lt;p&gt;| 项目 | 价格 | 数量 |
| ——– | —–: | :—-: |
| 计算机 | $1600 | 5 |
| 手机 | $12 | 12 |
| 管线 | $1 | 234 |&lt;/p&gt;

&lt;p&gt;###HTML标签
Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格：&lt;/p&gt;
&lt;table&gt;
    &lt;tr&gt;
        &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt;
        &lt;th&gt;星期一&lt;/th&gt;
        &lt;th&gt;星期二&lt;/th&gt;
        &lt;th&gt;星期三&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;李强&lt;/td&gt;
        &lt;td&gt;张明&lt;/td&gt;
        &lt;td&gt;王平&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;#特别介绍
##转义字符
使用像C语言中的\来进行转义：
$\lim$
$ \lim $&lt;/p&gt;

&lt;p&gt;##多加空格
有些时候，有些支持Markdown的编辑类软件中，Markdown渲染失败，多半原因可能是没有空格导致的
比如：#中文，在#和中文之间加上一个空格就好了。这个问题我在很多地方遇到过，比如：Atom的Markdown Preview插件（这是一个Core Package）。&lt;/p&gt;

&lt;p&gt;##一个小建议
使用HTML或者LaTex，或者结合笔记类软件的富文本工具栏来实现一些在Markdown中不尽如人意的地方&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:footnote2&quot;&gt;
      &lt;p&gt;这是第二个&amp;nbsp;&lt;a href=&quot;#fnref:footnote2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 20 Jan 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/01/markdown%E8%AF%AD%E6%B3%95/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/01/markdown%E8%AF%AD%E6%B3%95/</guid>

        <category>标记语言</category>

        <category>语法</category>


        <category>教程</category>

      </item>

      <item>
        <title>git学习记录</title>
        <description>&lt;p&gt;git是由Linus Torvalds在开发linux内核时发明的一种软件版本控制工具，其实这就是一个文件版本控制工具，协同写作也可以用git，会十分方便，github就是用的git。git是分布式的版本控制系统，而SVN是集中式的版本控制系统（也就是星型网络，必须要有一个中央服务器）。&lt;/p&gt;

&lt;h1 id=&quot;相关教程&quot;&gt;相关教程&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot;&gt;廖雪峰的Git教程&lt;/a&gt;
&lt;a href=&quot;https://www.w3ctrain.com/2016/06/26/learn-git-in-30-minutes/&quot;&gt;30分钟git命令入门到放弃| w3cTrain&lt;/a&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/Git&quot;&gt;Git - Wikipedia&lt;/a&gt;
&lt;a href=&quot;https://git-scm.com/&quot;&gt;Git官网&lt;/a&gt;
&lt;a href=&quot;https://git-scm.com/doc&quot;&gt;git 官方文档&lt;/a&gt;
&lt;a href=&quot;https://marklodato.github.io/visual-git-guide/index-zh-cn.html&quot;&gt;图解git&lt;/a&gt;
&lt;a href=&quot;https://try.github.io&quot;&gt;Try Git: Git Tutorial&lt;/a&gt;
&lt;a href=&quot;https://git-scm.com/book/en/v2&quot;&gt;Pro Git&lt;/a&gt;
&lt;a href=&quot;http://gitref.org/&quot;&gt;Git Reference&lt;/a&gt;
&lt;a href=&quot;https://www.codeschool.com/courses/git-real/&quot;&gt;Code School Git 教程&lt;/a&gt;
&lt;a href=&quot;https://www.codecademy.com/learn/learn-git&quot;&gt;Codecadmy Git 教程&lt;/a&gt;
&lt;a href=&quot;https://guides.github.com/activities/hello-world/&quot;&gt;githubguides&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;#配置git
安装完git,首要任务是配置我们的信息，最重要的是用户名及邮箱，打开终端，执行以下命令。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git config --global user.name &quot;My Name&quot;w
git config --global user.email myEmail@example.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置好这两项，用户就能知道谁做了什么，并且一切都更有组织性了不是吗？&lt;/p&gt;

&lt;h1 id=&quot;常用git命令&quot;&gt;常用git命令&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;最常用的用红色字体标出了&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;git init  //把当前目录变成一个带git版本控制的目录，简单的说就是变成git目录&lt;/li&gt;
  &lt;li&gt;$\color{red}{git \ add \ .}$ //把所有修改过的东西都添加到git仓库，.表示当前目录&lt;/li&gt;
  &lt;li&gt;git status    //看是否有改动还没有提交&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其实git会自己有提示，如上图那个黄色的叉叉就表示有新的改动没有提交。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;git diff  file_name  //查看一个文件哪里被修改了&lt;/li&gt;
  &lt;li&gt;git  commit  -m  “message”  //把添加的东西确认提交，并填写好确认信息（一般写上做了什么改动）
&lt;strong&gt;这里要讲的一点就是要尽量少的使用这条命令，而尽量多的使用git add，因为git commit会提交到版本库的最终状态（快照）树中，并通过HEAD和branch来管理这些版本，每个状态都应该是一个值得记住的状态（快照）才对，如果你拼命的提交就会产生非常多的快照，这样非常不利于管理。所以不要把git commit当git add使，有什么改动都先git add到暂存区，最后有了大的变动和有意义的变动或者解决了某个问题，再git commit到状态（快照）树中。&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;git log //查看日志（回顾历史版本）&lt;/li&gt;
  &lt;li&gt;git reflog    //查看日志（回顾所有版本，及版本切换操作）&lt;/li&gt;
  &lt;li&gt;git reset --hard HEAD^  //回退一个版本，HEAD代表当前版本，HEAD^表示上一个版本，HEAD^^表示上上个版本，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100，当然也可以通过版本号回去。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如图是git log所输出的信息，commit后面跟着的就是版本号，按Q可以退出次界面。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;git checkout – file_name     //撤销修改。
命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：
一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；
一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。
总之，就是让这个文件回到最近一次git commit或git add时的状态。
git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;#远端仓库
为了能够协同开发，我们需要把代码发布到远端仓库上。
##链接远端仓库-git remote add&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git remote add origin https://github.com/teasion/blog.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个项目可以同时拥有好几个远端仓库为了能够区分，通常会起不同的名字。通常主远端仓库被称为origin。&lt;/p&gt;

&lt;p&gt;##上传到服务器-git push
每次我们要提交代码到服务器上时，都会使用到git push。
git push命令会有两个参数，远端仓库的名字，以及分支的名字：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git push origin gh-pages
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;push过程你可能需要验证身份。
为此我们可以添加SSH密钥到github上。
这里有篇相关教程：&lt;a href=&quot;https://segmentfault.com/a/1190000002645623&quot;&gt;git-ssh 配置和使用&lt;/a&gt;
##克隆仓库-git clone
放在Github上的开源项目，人们可以看到你的代码。可以使用 git clone进行下载到本地。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/teasion/blog.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本地也会创建一个新的仓库，并自动将github上的分支设为远端分支。&lt;/p&gt;

&lt;p&gt;##从服务器上拉取代码-git pull&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git pull origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你更新了代码到仓库上，其他人可以通过git pull命令拉取你的变动&lt;/p&gt;

&lt;p&gt;#分支讲解&lt;/p&gt;

&lt;p&gt;当你在做一个新功能的时候，最好是在一个独立的区域上开发，通常称之为分支。分支之间相互独立，并且拥有自己的历史记录。这样做的原因是：
稳定版本的代码不会被破坏
不同的功能可以由不同开发者同时开发。
开发者可以专注于自己的分支，不用担心被其他人破坏了环境
在不确定之前，同一个特性可以拥有几个版本，便于比较
##创建新分支-git branch
每一个仓库的默认分支都叫master, 创建新分支可以这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git branch amazing_new_feature
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建了一个名为amazing_new_feature的新分支，它跟当前分支同一起点&lt;/p&gt;

&lt;p&gt;单独使用git branch，可以查看分支状态：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git branch
  amazing_new_feature
* master
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;号表示当前活跃分支为master，使用git checkout切换分支。
##切换分支-git checkout
    &lt;pre&gt;&lt;code&gt;git checkout amazing_new_feature
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;##合并分支
我们的 amazing_new_feature 分支的任务是增加一个featuer.txt。我们来创建，添加到暂存区，提交。&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;$ git add feature.txt
$ git commit -m &quot;New feature complete.&quot;
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;新分支任务完成了，回到master分支&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;git checkout master
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;现在去查看文件，你会发现，之前创建的feature.txt文件不见了，因为master分支上并没有feature.txt。使用git merge 把 amazing_new_feature 分支合并到master上。&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;git merge amazing_new_feature
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;ok! 然后再把amazing_new_feature 分支删掉吧。&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;git branch -d amazing_new_feature
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;#进阶操作
##比对两个不同提交之间的差别
每次提交都有一个唯一id，查看所有提交和他们的id，可以使用 git log:
查看某一次提交更新了什么，使用 git show 快照的ID（id 很长，但是你并不需要复制整个字符串，前一小部分就够了。）
查看两次提交的不同，可以使用git diff [commit-from]..[commit-to] 语法：&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;$ git diff 09bd8cc..ba25c0ff
diff --git a/feature.txt b/feature.txt
new file mode 100644
index 0000000..e69de29
diff --git a/hello.txt b/hello.txt
index e69de29..b546a21 100644
--- a/hello.txt
+++ b/hello.txt
@@ -0,0 +1 @@
+Nice weather today, isn't it?
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;比较首次提交和最后一次提交，我们可以看到所有的更改。当然使用git difftool命令更加方便。
##回滚某个文件到之前的版本
git 允许我们将某个特定的文件回滚到特定的提交，使用的也是 git checkout。
下面的例子，我们将hello.txt回滚到最初的状态，需要指定回滚到哪个提交，以及文件的全路径。&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;git checkout 09bd8cc1 hello.txt
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;##解决合并冲突
冲突经常出现在合并分支或者是拉去别人的代码。有些时候git能自动处理冲突，但大部分需要我们手动处理。
比如John 和 Tim 分别在各自的分支上写了两部分代码。
John 喜欢 for:&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;// Use a for loop to console.log contents.
for(var i=0; i&amp;lt;arr.length; i++) {
console.log(arr[i]);
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;Tim 喜欢 forEach:&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;// Use forEach to console.log contents.
arr.forEach(function(item) {
console.log(item);
});
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;假设John 现在去拉取 Tim的代码:&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;$ git merge tim_branch
Auto-merging print_array.js
CONFLICT (content): Merge conflict in print_array.js
Automatic merge failed; fix conflicts and then commit the result.
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;这时候git并不知道如何解决冲突，因为他不知道John和Tim谁写得更好。
于是它就在代码中插入标记。&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD
// Use a for loop to console.log contents.
for(var i=0; i&amp;lt;arr.length; i++) {
  console.log(arr[i]);
}
=======
// Use forEach to console.log contents.
arr.forEach(function(item) {
  console.log(item);
});
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; Tim s commit.
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;==== 号上方是当前最新一次提交，下方是冲突的代码。我们需要解决这样的冲突，经过组委会成员讨论，一致认定，在座的各位都是垃圾！两个都不要。改成下面的代码。&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;// Not using for loop or forEach.
// Use Array.toString() to console.log contents.
console.log(arr.toString());
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;好了，再提交一下：&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;$ git add -A
$ git commit -m &quot;Array printing conflict resolved.&quot;
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;如果在大型项目中，这个过程可能容易出问题。你可以使用GUI 工具来帮助你。使用 git mergetool。
##配置.gitignore
大部分项目中，会有写文件，文件夹是我们不想提交的。为了防止一不小心提交，我们需要gitignore文件：&lt;/p&gt;
    &lt;ol&gt;
      &lt;li&gt;在项目根目录创建.gitignore文件&lt;/li&gt;
      &lt;li&gt;在文件中列出不需要提交的文件名，文件夹名，每个一行&lt;/li&gt;
      &lt;li&gt;.gitignore文件需要提交，就像普通文件一样&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通常会被ignore的文件有：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;log文件&lt;/li&gt;
  &lt;li&gt;task runner builds&lt;/li&gt;
  &lt;li&gt;node_modules等文件夹&lt;/li&gt;
  &lt;li&gt;IDEs生成的文件&lt;/li&gt;
  &lt;li&gt;个人笔记
例如：
    &lt;pre&gt;&lt;code&gt;*.log
build/
node_modules/
.idea/
my_notes.txt
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;#git概念和原理
&lt;strong&gt;工作区（Working Directory）&lt;/strong&gt;，就是你电脑中能看到的目录。
&lt;strong&gt;版本库（Repository）&lt;/strong&gt;，工作区有个隐藏目录.git，这个不算工作区，而是git的版本库。
Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。&lt;/p&gt;

&lt;p&gt;前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：
第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；
第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。
因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。
你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。
每次修改，如果不add到暂存区，那就不会加入到commit中。&lt;/p&gt;

&lt;p&gt;#实用git工具
&lt;a href=&quot;https://www.gitignore.io/&quot;&gt;在线创建.gitignore&lt;/a&gt;
&lt;a href=&quot;https://git-scm.com/doc&quot;&gt;git 官方文档&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 20 Jan 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/01/git%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/01/git%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</guid>

        <category>工具</category>

        <category>git</category>

        <category>记录</category>


        <category>教程</category>

      </item>

      <item>
        <title>Python游戏开发之BombMan</title>
        <description>&lt;h2 id=&quot;环境安装&quot;&gt;环境安装&lt;/h2&gt;

&lt;p&gt;Python3、pygame&lt;/p&gt;

&lt;p&gt;我用的是 &lt;strong&gt;macbook&lt;/strong&gt;，下面讲讲 &lt;strong&gt;mac OS&lt;/strong&gt; 的环境搭建：&lt;/p&gt;

&lt;p&gt;先使用homebrew安装Python3.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://wx2.sinaimg.cn/mw690/006zFO3ggy1fbvru5hipoj30g403sjrw.jpg&quot; alt=&quot;brew list&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到我已经安装好了Python3。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;关于homebrew的安装和使用教程网上很多，我这里就不写了，有疑问可以在评论里面提，我将一一解答&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然后安装pygame:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pip3 install pygame&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我在使用pygame的时候遇到了一点问题，我的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# coding=utf-8

import pygame
from pygame.locals import *

pygame.init()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Pycharm（python的IDE，Integrated Development Environmnet，集成开发环境）中&lt;code&gt;from pygame.locals import *&lt;/code&gt;显示是灰色的（unused import statement，没有用到的导入语句），而且提示init()不存在。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这时候你该想到可能是平台的问题了&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上谷歌搜索：mac Python3 pygame，我找到这个页面：http://pygame.org/wiki/macintosh&lt;/p&gt;

&lt;p&gt;安装上面的指示，我安装了XQuartz，重启macbook，解决了问题。&lt;/p&gt;

&lt;p&gt;这时候依然有个问题：&lt;code&gt;cannot find reference 'load' in 'image.py'&lt;/code&gt;。看到这个问题，我心态有点爆炸，暗骂道，什么鬼。&lt;/p&gt;

&lt;p&gt;我按照这：https://gist.github.com/ExPHAT/0cfc67ceb8982d11fd27
上面装了那些软件，依旧没有卵用，而且这个问题实在蹊跷。&lt;/p&gt;

&lt;p&gt;最后终于揭晓了问题原因，IDE没找到load函数而已，程序依旧可以运行正确。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#coding=utf-8

# 1 - Import library
import pygame
from pygame.locals import *

# 2 - Initialize the game
pygame.init()
width, height = 640, 480
screen = pygame.display.set_mode((width, height))

# 3 - Load images
player = pygame.image.load(u&quot;./宝宝加油.png&quot;)

# 4 - keep looping through
while 1:
    # 5 - clear the screen before drawing it again
    screen.fill(0)
    # 6 - draw the screen elements
    screen.blit(player, (100, 100))
    # 7 - update the screen
    pygame.display.flip()
    # 8 - loop through the events
    for event in pygame.event.get():
        # check if the event is the X button
        if event.type == pygame.QUIT:
            # if it is quit the game
            pygame.quit()
            exit(0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码运行效果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://wx4.sinaimg.cn/mw690/006zFO3ggy1fbwtk3wpqej30zq0rw1kx.jpg&quot; alt=&quot;代码运行效果&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;架构&quot;&gt;架构&lt;/h2&gt;

&lt;p&gt;搞定了环境，就开始分析游戏架构。&lt;/p&gt;

&lt;p&gt;首先必不可少的目录：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;src（source的缩写，存放代码）&lt;/li&gt;
  &lt;li&gt;res（resource的缩写，存放资源，如：音乐、图片）&lt;/li&gt;
  &lt;li&gt;data（存放游戏数据，如：地图、人物属性、游戏进度等等）&lt;/li&gt;
  &lt;li&gt;lib（library，存放第三库）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个炸弹人游戏是仿泡泡堂制作的，大家应该都玩过。&lt;/p&gt;
</description>
        <pubDate>Thu, 19 Jan 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/01/Python%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B9%8BBombMan/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/01/Python%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B9%8BBombMan/</guid>

        <category>游戏</category>

        <category>Python</category>

        <category>编程</category>


        <category>实战</category>

      </item>

      <item>
        <title>leetcode讲解--401. Binary Watch</title>
        <description>&lt;h2 id=&quot;401-binary-watch&quot;&gt;401. Binary Watch&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/binary-watch/&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59).&lt;/p&gt;

&lt;p&gt;Each LED represents a zero or one, with the least significant bit on the right.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/8/8b/Binary_clock_samui_moon.jpg&quot; alt=&quot;二进制手表&quot; /&gt;&lt;/p&gt;

&lt;p&gt;For example, the above binary watch reads “3:25”.&lt;/p&gt;

&lt;p&gt;Given a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;p&gt;Input: n = 1&lt;/p&gt;

&lt;p&gt;Return: [“1:00”, “2:00”, “4:00”, “8:00”, “0:01”, “0:02”, “0:04”, “0:08”, “0:16”, “0:32”]&lt;/p&gt;

&lt;p&gt;Note:&lt;/p&gt;

&lt;p&gt;The order of output does not matter.&lt;/p&gt;

&lt;p&gt;The hour must not contain a leading zero, for example “01:00” is not valid, it should be “1:00”.&lt;/p&gt;

&lt;p&gt;The minute must be consist of two digits and may contain a leading zero, for example “10:2” is not valid, it should be “10:02”.&lt;/p&gt;

&lt;h3 id=&quot;翻译&quot;&gt;翻译&lt;/h3&gt;

&lt;p&gt;一个二进制手表有4个LED灯在表盘的上部，代表（0-11）个小时，且有6个LED灯在表盘的底部，代表（0-59）分钟。&lt;/p&gt;

&lt;p&gt;每个LED灯代表0或者1，权重最小的比特位在右边。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/8/8b/Binary_clock_samui_moon.jpg&quot; alt=&quot;二进制手表&quot; /&gt;&lt;/p&gt;

&lt;p&gt;例如，上面的二进制表读作：”3：25”&lt;/p&gt;

&lt;p&gt;给定一个非负整数 n ，n 代表亮着的LED灯的个数，返回手表所有可能表示的时间。&lt;/p&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;p&gt;输入： n = 1&lt;/p&gt;

&lt;p&gt;返回：[“1:00”, “2:00”, “4:00”, “8:00”, “0:01”, “0:02”, “0:04”, “0:08”, “0:16”, “0:32”]&lt;/p&gt;

&lt;p&gt;注意：&lt;/p&gt;

&lt;p&gt;输出顺序任意。&lt;/p&gt;

&lt;p&gt;小时不能以0开头，例如：”01:00”是无效的，而应该是”1:00”。&lt;/p&gt;

&lt;p&gt;分钟必须包含两个数字且可能包含开头是0的情况，例如：”10:2”是无效的，而应该是”10:02”。&lt;/p&gt;

&lt;h3 id=&quot;分析&quot;&gt;分析&lt;/h3&gt;

&lt;h4 id=&quot;位运算&quot;&gt;位运算&lt;/h4&gt;

&lt;p&gt;总共有10个位，遍历0~1024，当1的个数等于num时，利用位运算抽取小时，分钟的读数，然后符合条件（小时在0-11之间，分钟在0-59之间）就加进结果集里。&lt;/p&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution(object):
    def readBinaryWatch(self, num):
        &quot;&quot;&quot;
        :type num: int
        :rtype: List[str]
        &quot;&quot;&quot;
        ans = []
        for i in range(0,1024):
            if bin(i).count('1') == num:
                h, m = i&amp;gt;&amp;gt;6, i&amp;amp;0x3F
                if h&amp;lt;12 and m&amp;lt;60:
                    ans += '%d:%02d' %(h, m),
        return ans

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;枚举&quot;&gt;枚举&lt;/h4&gt;

&lt;p&gt;枚举小时和分钟（共12*60种），读取1的个数，如果和num相等就加进结果集。&lt;/p&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution(object):
    def readBinaryWatch(self, num):
        &quot;&quot;&quot;
        :type num: int
        :rtype: List[str]
        &quot;&quot;&quot;
        ans = []
        for h in range(12):
            for m in range(60):
                if bin(h).count('1')+bin(m).count('1')==num:
                    ans.append(&quot;%d:%02d&quot; %(h,m))
        return ans
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Wed, 18 Jan 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/01/leetcode%E8%AE%B2%E8%A7%A3-401.-Binary-Watch/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/01/leetcode%E8%AE%B2%E8%A7%A3-401.-Binary-Watch/</guid>

        <category>算法</category>

        <category>编程</category>

        <category>leetcode</category>


        <category>leetcode</category>

      </item>

      <item>
        <title>leetcode讲解--268. Missing Number</title>
        <description>&lt;h2 id=&quot;268-missing-number&quot;&gt;268. Missing Number&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/missing-number/&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.&lt;/p&gt;

&lt;p&gt;For example,
Given nums = [0, 1, 3] return 2.&lt;/p&gt;

&lt;p&gt;Note:
Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?&lt;/p&gt;

&lt;h3 id=&quot;翻译&quot;&gt;翻译&lt;/h3&gt;

&lt;p&gt;给定一个数组包含 0, 1, 2, …, n， n个不相同的数字，从数组中找出这个缺失的数。&lt;/p&gt;

&lt;p&gt;例如，&lt;/p&gt;

&lt;p&gt;给定 nums = [0, 1, 3] 返回 2。&lt;/p&gt;

&lt;p&gt;注意：&lt;/p&gt;

&lt;p&gt;你的算法应该运行在线性的时间复杂度内。你能只使用常数空间复杂度来实现它吗？&lt;/p&gt;

&lt;h3 id=&quot;分析&quot;&gt;分析&lt;/h3&gt;

&lt;p&gt;这题极其简单啊，用加减法就能找出那个数啊。&lt;/p&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution(object):
    def missingNumber(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        count1=0
        count2=0
        for i in range(len(nums)+1):
            count1 += i
        for i in nums:
            count2 += i
        return count1-count2
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Wed, 18 Jan 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/01/leetcode%E8%AE%B2%E8%A7%A3-268.-Missing-Number/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/01/leetcode%E8%AE%B2%E8%A7%A3-268.-Missing-Number/</guid>

        <category>算法</category>

        <category>编程</category>

        <category>leetcode</category>


        <category>leetcode</category>

      </item>

  </channel>
</rss>
