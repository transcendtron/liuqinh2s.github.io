---
layout: post
title: leetcode讲解之开篇--486. Predict the Winner
categories: leetcode
tags: [算法, leetcode, 编程]
comments: true
---

### 486. Predict the Winner

Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins.

Given an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score.

Example 1:

Input: [1, 5, 2]

Output: False

Explanation: Initially, player 1 can choose between 1 and 2.

If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2).

So, final score of player 1 is 1 + 2 = 3, and player 2 is 5.

Hence, player 1 will never be the winner and you need to return False.

Example 2:

Input: [1, 5, 233, 7]

Output: True

Explanation: Player 1 first chooses 1. Then player 2 have to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.

Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.

Note:

1 <= length of the array <= 20.

Any scores in the given array are non-negative integers and will not exceed 10,000,000.

If the scores of both players are equal, then player 1 is still the winner.

#### 翻译

给定一个非负的整形的数组（数组中装的数称为分数）。玩家1从数组的任意一端挑走一个数，接着是玩家2，接着又是玩家1。每次一个玩家挑走一个数，这个数就不能被下一个玩家挑了。一直这样直到所有分数都被选走。拥有分数总和多的玩家获胜。

给定一个包含分数的数组，预言玩家1是否会赢。你应该假设每个玩家都想要把自己的分数最大化。

例子1：

输入：[1, 5, 2]

输出: False

解释: 初始条件下, 玩家1可以在 1 和 2 之间选择。

如果他选择 2 (或 1), 然后玩家2能从 1（或者 2）和 5 之间选择. 如果玩家2选择5, 然后玩家1只剩下 1 或者 2 可以选择。

所以最后玩家1的分数是 3 ，玩家2的分数是 5。

因此，玩家1不可能赢，你应该返回 False。

例子2：

输入: [1, 5, 233, 7]

输出: True

解释: 玩家1首先选择1. 玩家2必须在 5 和 7 之间选择. 不管玩家2选择哪个数, 玩家1总能选到233。

最后玩家1（234）比玩家2（12）拥有更多的分数, 所以你应该返回True，代表玩家1会赢。

注意：

1 <= 数组的长度 <= 20。

给定的数组中的每个分数都是非负的并且不会超过10,000,000。

如果每个玩家的分数都是相等的，那么玩家1就是赢家。

#### 分析

这是一个典型的[Minimax算法](https://zh.wikipedia.org/wiki/%E6%9E%81%E5%B0%8F%E5%8C%96%E6%9E%81%E5%A4%A7%E7%AE%97%E6%B3%95)的案例，两个玩家都要使自己的利益最大化，使对手的利益最小化。Minimax是一个[零和博弈](https://zh.wikipedia.org/wiki/%E9%9B%B6%E5%92%8C%E5%8D%9A%E5%BC%88)中的算法。而[Alpha-beta剪枝](https://zh.wikipedia.org/wiki/Alpha-beta%E5%89%AA%E6%9E%9D)则是一个基于Minimax的剪枝算法（当算法评估出某策略的后续走法比之前策略的还差时，就会停止计算该策略的后续发展）。

Minimax算法伪代码：
```
function minimax(node, depth)
    if node is a terminal node or depth = 0
        return the heuristic value of node
    if the adversary is to play at node
        let α := +∞
        foreach child of node
            α := min(α, minimax(child, depth-1))
    else {we are to play at node}
        let α := -∞
        foreach child of node
            α := max(α, minimax(child, depth-1))
    return α
```

当你看上面的伪代码，有没有注意到，在对手回合时，我们这个算法默认对手的收益是无穷大，而在自己回合时，我们这个算法默认我们的收益是无穷小。这是一种 **选择总比不选择好** 的算法，也就是说我们默认必须要从子节点中选出一个最佳的，而不能什么都不选（默认什么都不选时情况最差）。换过来思考，如果我们默认：对手的收益是无穷小，自己收益无穷大。那我们什么都不用做了，因为任何选择都好不过使对手收益无穷小，自己收益无穷大，也就是说无论什么情况不选择任何一个子节点就行了（不选择比选择要好）。

##### 解题思路

```
我们用一个solve(nums)函数来计算当前玩家从nums中可以获得的最大收益，当收益>=0时，玩家1获胜。
solve(nums) = max(nums[0] - solve(nums[1:]), nums[-1] - solve(nums[:-1]))
为什么是nums[0]-solve(nums[1:])而不是+呢？因为玩家拿完一个数之后就轮到别人了，
此时solve函数是别人的收益，
我们用累计自己收益，并扣除对手收益的方式来表示自己的收益最后是否比对手多
（如果结果大于0就表示比对手多）。
```

这里能不能用Alpha-beta剪枝呢？很明显不能，因为我们缺少评估方法，也就是说，后序的走法（拿法）我们无法评估是好是坏，要算下去（递归下去）才知道。**我们做不出这个评估，所以我们就无法剪枝了**（如果我们能评估max函数的参数中是第一个大还是第二个大，我们就能剪去差的，留下好的。这里的话，问题是很具体的，复杂程度比起国际象棋和围棋这种要低很多，我们完全可以把每种可能都计算到，而且也 **必须把每种情况都计算进来**（这是题目的隐性要求啊，就是要从所有情况中算出是否能赢来啊，没叫你评估啊） ，所以没必要用到评估算法和剪枝）。

另外我们发现，在用Minimax算法的时候可能会有重复的计算，比如输入如果是[1, 5, 233, 7]的话，solve([5, 233])就会被重复计算。所以我们可以用记忆化。

```Python
class Solution(object):
    def PredictTheWinner(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        cache = dict()
        def solve(nums):
            if len(nums)<=1:
                return sum(nums)
            tnums = tuple(nums)
            if tnums in cache:
                return cache[tnums]
            cache[tnums] = max(nums[0]-solve(nums[1:]), nums[-1]-solve(nums[:-1]))
            return cache[tnums]
        return solve(nums)>=0
```
