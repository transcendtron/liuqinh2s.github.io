---
layout: post
title: 操作系统简要笔记
categories: 文章
tags: [操作系统]
comments: true
---

## 进程管理

## 内存管理

内存管理的功能有：
- 内存空间的分配和回收：由操作系统完成主存储器空间的分配和管理，使程序员摆脱存储分配的麻烦，提高编程的效率。
- 地址转换：在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，因此存储管理必须提供地址变换功能，把逻辑地址转换成相应的物理地址。
- 内存空间的扩充：利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存
- 存储保护：保证各道作业在各自的存储空间中运行，互不干扰

C和C++程序装入和链接：
1. 预编译
2. 编译
3. 汇编
4. 链接
5. 装入

程序链接有三种方式：
- 静态链接：在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的可执行程序，再装入内存。
- 装入时动态链接：将用户源程序编译后得到的一组目标模块，在装入内存时，采用边装入边链接的链接方式。
- 运行时动态链接：对某些目标模块的链接，是在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。缺点是把装入时间打散到程序运行期间，牺牲了程序运行中的时间。

装入时同样有三种方式：
- 绝对装入：只适用于单道程序环境，使用内存物理地址装入。
- 可重定位装入：也称，静态重定位，使用相对地址，装入时转换成绝对地址（地址变换一次性完成）。
- 动态运行时装入：也称，动态重定位，使用相对地址，装入时，使用重定位寄存器，转换成绝对地址（地址变换可多次进行，可以将程序分配到不连续的存储区，在程序开始运行时只装入一部分代码即可投入运行，后期在程序运行期间可再动态申请内存）。

内存保护可以采取两种方法：
- 在CPU中设置一对上、下限寄存器，存放用户作业在主存中的上限、下限地址，每当CPU要访问一个地址时，分别和两个寄存器的值比较，判断有无越界。
- 采用界地址寄存器（又称限长寄存器）和重定位寄存器（或基址寄存器）来实现保护。首先每个逻辑地址值必须小于界地址寄存器的值，然后再加上基址，映射成物理地址。

扩充内存的两个方法：
- 覆盖：把用户空间分为一个固定区和若干个覆盖区，活跃的程序放入固定区，不活跃的程序按时间进行覆盖，覆盖用于同一个程序或进程中，由于覆盖技术要求给出程序段之间的覆盖结构，使得其对用户和程序员不透明，所以现代操作系统是通过虚拟内存技术来解决的，覆盖技术已经成为历史。
- 交换：换入换出，进程调度中的中级调度就是采用交换技术，交换用于不同的进程或作业之间（也称虚拟内存技术）。

连续分配管理方式：
- 单一连续分配，单道程序
- 固定分区分配，内部碎片
- 动态分区分配，外部碎片，首次适应（FF，First Fit），最佳适应（BF，Best Fit），最坏适应（WF，Worst Fit，又称：最大适应，Largest Fit），邻近适应（NF，Next Fit，循环首次适应）

非连续分配管理方式：

根据分区的大小是否固定分为：分页存储管理 和 分段存储管理

分页存储管理方式中，根据运行作业是否要把作业的所有页面都装入内存才能运行分为基本分页存储管理方式和请求分页存储管理方式。

#### 基本分页存储管理方式

分页存储的几个基本概念：

页面和页面大小。进程中的块称为 **页（page）**，内存中的块称为 **页框（page frame，或页帧）**，外存也以同样的单位进行划分，直接称为 **块（block）**

页表，页表项：第一项：页号，第二项：块号。页号P，页内偏移量W，可以确定物理存储位置（通过页号查找页表中相应的块号）。单位页太小则表太长，降低索引效率（时间）；单位页太长则产生碎片大，空间利用率下降（空间）。

系统中通常设置一个 **页表寄存器（PTR）**，存放页表在内存中的始址F和页表长度M。进程未执行时，页表的始址和长度存放在进程控制块中，当进程执行时，才将页表始址和长度存入页表寄存器。

设页面大小为L，逻辑地址A 到 物理地址E 的变换过程如下：
1. 计算页号P（P=A/L）和页面偏移量W（W=A%L）
2. 比较页号长度P和页表长度M，若P>=M，则产生越界中断，否则继续执行。
3. 页表中页号P对应的页表项地址=页表起始地址F+页号P*页表项长度，取出该页表项内容b，即为物理块号。
4. 计算 E=b*L+W，用得到的物理地址E去访问内存。

习题：若页面大小L为1K字节，页号2对应的物理块号为b=8，计算逻辑地址A=2500的物理地址E。

**快表** -- 具有并行查找能力的高速缓冲存储器，又称：联想寄存器（TLB），与此对应，主存中的页表也常称为 **慢表**

一般快表的命中率可以达到90%以上，这样，分页带来的速度损失就降到10%以下。快表的有效性是基于著名的局部性原理。

查快表的方式也有两种，一种是先查快表没找到再查慢表，一种是同时查快表慢表，如果在快表中找到就终止对慢表的查找。

我们来分析一下页表的大小：假定逻辑地址空间是2^32，也就是4G，页面大小4KB，那么就会有2^20次方个页面，如果页表项大小是4B，那么一个页表就是4MB的空间，而每个进程都拥有一个页表，显然这种开销是不能让人接受的。所以需要两级页表。

为了查询方便，顶级页表最多只能有1页，页面大小是4KB，那么页内偏移地址log4K=12位，那么顶级页表可以容纳4KB/4B=1K个页表项，占用的地址位数：log1K=10位，二级页表的地址空间只剩 32-12-10=10位。

#### 基本分段存储管理方式

分页管理方式是从计算机的角度考虑设计的，以提高内存的利用率，且分页通过硬件机制实现，对用户完全透明；而分段管理方式的提出则是考虑了用户和程序员，以满足方便编程、信息保护和共享、动态增长以及动态链接等多方面的需要。

分段。段式管理方式按照用户进程中的自然段划分逻辑空间。例如，用户进程由主程序、两个子程序、栈和一段数据组成，于是可以把这个用户进程划分为5个段，每段从0开始编址，并分配一段连续的地址空间（段内要求连续，段间不要求连续，因此整个作业的地址空间是二维的）。其逻辑地址由 段号S 与 段内偏移量W 两部分组成。如果段号16位，段内偏移量16位，则一个作业最多可有 2^16=65536个段，最大段长64KB。

在页式系统中，逻辑地址的页号和页内偏移量对用户是透明的，但在段式系统中，段号和段内偏移量必须由用户显示提供，在高级的程序设计语言中，这个工作由编译程序完全。

段表：段表项包括：段号，段长，本段在内存中的起始地址。
