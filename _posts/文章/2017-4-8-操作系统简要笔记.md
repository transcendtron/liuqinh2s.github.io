---
layout: post
title: 操作系统简要笔记
categories: 文章
tags: [操作系统]
comments: true
---

## 进程管理

## 内存管理

内存管理的功能有：
- 内存空间的分配和回收：由操作系统完成主存储器空间的分配和管理，使程序员摆脱存储分配的麻烦，提高编程的效率。
- 地址转换：在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，因此存储管理必须提供地址变换功能，把逻辑地址转换成相应的物理地址。
- 内存空间的扩充：利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存
- 存储保护：保证各道作业在各自的存储空间中运行，互不干扰

C和C++程序装入和链接：
1. 预编译
2. 编译
3. 汇编
4. 链接
5. 装入

程序链接有三种方式：
- 静态链接：在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的可执行程序，再装入内存。
- 装入时动态链接：将用户源程序编译后得到的一组目标模块，在装入内存时，采用边装入边链接的链接方式。
- 运行时动态链接：对某些目标模块的链接，是在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。缺点是把装入时间打散到程序运行期间，牺牲了程序运行中的时间。

装入时同样有三种方式：
- 绝对装入：只适用于单道程序环境，使用内存物理地址装入。
- 可重定位装入：也称，静态重定位，使用相对地址，装入时转换成绝对地址（地址变换一次性完成）。
- 动态运行时装入：也称，动态重定位，使用相对地址，装入时，使用重定位寄存器，转换成绝对地址（地址变换可多次进行，可以将程序分配到不连续的存储区，在程序开始运行时只装入一部分代码即可投入运行，后期在程序运行期间可再动态申请内存）。

内存保护可以采取两种方法：
- 在CPU中设置一对上、下限寄存器，存放用户作业在主存中的上限、下限地址，每当CPU要访问一个地址时，分别和两个寄存器的值比较，判断有无越界。
- 采用界地址寄存器（又称限长寄存器）和重定位寄存器（或基址寄存器）来实现保护。首先每个逻辑地址值必须小于界地址寄存器的值，然后再加上基址，映射成物理地址。

扩充内存的两个方法：
- 覆盖：把用户空间分为一个固定区和若干个覆盖区，活跃的程序放入固定区，不活跃的程序按时间进行覆盖，覆盖用于同一个程序或进程中，由于覆盖技术要求给出程序段之间的覆盖结构，使得其对用户和程序员不透明，所以现代操作系统是通过虚拟内存技术来解决的，覆盖技术已经成为历史。
- 交换：换入换出，进程调度中的中级调度就是采用交换技术，交换用于不同的进程或作业之间（也称虚拟内存技术）。

连续分配管理方式：
- 单一连续分配，单道程序
- 固定分区分配，内部碎片
- 动态分区分配，外部碎片，首次适应（FF，First Fit），最佳适应（BF，Best Fit），最坏适应（WF，Worst Fit，又称：最大适应，Largest Fit），邻近适应（NF，Next Fit，循环首次适应）

非连续分配管理方式：

根据分区的大小是否固定分为：分页存储管理 和 分段存储管理

分页存储管理方式中，根据运行作业是否要把作业的所有页面都装入内存才能运行分为基本分页存储管理方式和请求分页存储管理方式。

分页存储的几个基本概念：

页面和页面大小。进程中的块称为 **页（page）**，内存中的块称为 **页框（page frame，或页帧）**，外存也以同样的单位进行划分，直接称为 **块（block）**

页表，页表项：第一项：页号，第二项：块号。页号P，页内偏移量W，可以确定物理存储位置（通过页号查找页表中相应的块号）。单位页太小则表太长，降低索引效率（时间）；单位页太长则产生碎片大，空间利用率下降（空间）。
