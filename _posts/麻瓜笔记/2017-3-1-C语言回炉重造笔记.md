---
layout: post
title: C语言回炉重造笔记
categories: 麻瓜笔记
tags: [C语言, 教程, 编程语言]
comments: true
---

# C缺陷与陷阱

## 词法“陷阱”

### `=` 不同于 `==`

为什么赋值使用`=`，比较使用`==`呢？

由Algol派生而来的大多数程序设计语言，例如 Pascal 和 Ada，使用符号 `:=` 作为赋值运算符，符号 `=` 作为比较运算符。而C语言使用另一种表示法，符号 `=` 作为赋值运算符，符号 `==` 作为比较运算符。**一般而言赋值运算相对于比较运算出现得更频繁，因为字符较少的 `=` 就被赋予了更常用的含义--赋值操作。** 此外，**在C语言中赋值符号被作为一种操作符对待**，因而重复进行赋值操作（a=b=c）可以很容易地书写，并且赋值操作还可以被嵌入到更大的表达式当中去。

由此产生一个问题，**很多新手容易将比较运算符 `==` 错写成赋值运算符 `=`**。

看例子：

```c
while(c = ' ' || c == '\t' || c == '\n')
  c = getc(f);
```

由于程序员在比较 `' '` 和 c 时，误将比较运算符 `==` 写成了 赋值运算符 `=` 。 因为赋值运算符 `=` 的优先级要低于逻辑运算符 `||` ，因此实际上是以下表达式 `' ' || c == '\t' || c == '\n'` 赋给了 c 。因为 `' '`不等于0（`' '`的ASCII码值为32），**那么无论变量c此前为何值，上述表达式求值的结果都是1**，因此循环将一直进行下去直到整个文件结束。文件结束之后循环是否还会进行下去，这取决于 `getc` 库函数的具体实现，在文件指针达到文件结尾之后是否还允许继续读取字符。如果允许继续读取字符，那么循环将一直进行下去，从而成为一个死循环。

### 词法分析中的贪心法

一些 C 记号，如 `/、*和=` 只有一个字符。而其他一些 C 记号，如 `/*和==` ，以及标识符，具有多个字符。当 C 编译器遇到紧连在一起的/和*时，它必须能够决定是将这两个字符识别为两个分离的记号还是一个单独的记号。C语言对这个问题的解决方案可以归结为一个很简单的规则：每个符号应该包含尽可能多的字符。这个策略被称为 **贪心法**。

看例子：

表达式

```c
a --- b
```

与表达式

```c
a -- - b
```

的含义相同，而与

```c
a - -- b
```

的含义不同。

### 整形常量与进制

如果整形常量的第一个字符是数字0，那么该常量将被视作八进制数，因此，10与010的含义截然不同。0x代表16进制。

### 强制类型转换

```c
int i;
i = 19.5;
printf("%d",i);
i = 19.6;
printf("%d",i);
```

结果都是19。可见这里并没有四舍五入，而是直接截取整数部分。

### C语言没有bool

在C语言标准(C89)没有定义布尔类型，所以C语言判断真假时以0为假，非0为真。

条件运算符是唯一一个有3个操作数的运算符，所以有时又称三元运算符。

```c
int i,a,b;
i = 19;
a = -20;
b = (a+i)?a:i;
printf("%d\n", b);
```

结果是-20。你可以看到由于C语言没有bool类型，所以只能直接对整形的数进行判断了，只要不是0，就是真，负数也是真。

```c
#include <stdio.h>
int main()
{
    int i,a,b;
    i = 19;
    a = -20;
    b = (a+i)?a:i;
    if(a+i){
        printf("%d\n", a+i);
    }
    return 0;
}
```

同样if也是这个道理，只要不是0，都为真。

```C
//定义一个int类型变量，当变量值为0时表示false，值为1时表示true
int flag;
flag = 0;
//......
flag = 1;

if( flag )
{
//......
}
```

但这种做法不直观，而且没有明确flag一定是布尔值。所以我们又借助C语言的宏定义：

```c
//宏定义布尔类型
#define BOOL int
#define TRUE 1
#define FALSE 0

//定义一个布尔变量
BOOL flag = FALSE;
```

这种方法虽然直观，但依然是换汤不换药，变量flag在编译器看来依然是int类型。

　　新版本总会改进一些不好的地方，所以在最新的C语言标准(C99)解决了布尔类型的问题。C99提供了_Bool 型，所以布尔类型可以声明为 _Bool flag。

　　_Bool依然仍是整数类型，但与一般整型不同的是，_Bool变量只能赋值为0或1，非0的值都会被存储为1。

　　C99还提供了一个头文件 <stdbool.h> 定义了bool代表_Bool，true代表1，false代表0。只要导入 stdbool.h ，就能非常方便的操作布尔类型了。

```c
//导入 stdbool.h 来使用布尔类型
#include <stdbool.h>
#include <stdio.h>

//计算n!,n的值在main中定义
int main(void)
{
    int n = 10;    //计算叠乘数
    int sum = 1; //用来存放叠乘的结果
    bool flag = false;    //叠乘标记

    int num = n;    //循环次数
    while( !flag )
    {
        sum = sum * (num--);
        //当num=1时结束循环
        if( num == 1)
        {
            flag = true;
        }
    }
    printf ("%d的叠乘值为 %d \n", n, sum);
    return 0;
}
```

### 字符与字符串

C语言单引号和双引号含义迥异，在某些情况下把两者弄混，编译器并不会检测报错，从而在运行时产生难以预料的效果。

用单引号引起的一个字符实际上代表一个整数，整数值对应于该字符在编译器采用的字符集中的序列值，因此，对于采用ASCII字符集的编译器而言，`'a'`的含义与`0141`(八进制)或者`97`(十进制)严格一致。

用双引号引起的字符串，代表的确是一个指向无名数组起始字符的指针，该数组被引号之间的字符以及一个额外的二进制为零的字符'\0'初始化。

下面的这个语句：

```c
printf("Hello world\n");
//与
char s[] = {'H','e','l','l','o',' ','w','o','r','l','d','\n',0};
printf("%s\n", s);
```

![C语言字符和字符串](https://wx4.sinaimg.cn/mw690/006zFO3ggy1fd4ss43xi0j31080j8n3x.jpg)

## 语法“陷阱”

### 理解函数声明

任何C语言变量的声明都由两部分组成：类型以及一组类似表达式的声明符（declarator）。

```
float f,g;
float ((f));
float ff();
float *pf;
float *g(),(*h)();
(float (*)())
```

搞懂上面的，然后来个组合重磅的：

```
(* (void (*)())0)();
```

`(void (*)())0`的意思是对0进行强制类型转换，类型是：`void (*)()`，而这是一个函数指针(该指针指向一个函数的入口)，该函数返回值是void。

外面是一个函数调用，`(*funcptr)();`

用typedef可以实现相同的效果：

```
typedef void (*funcptr)();
(* (funcptr)0)();
```

再看下面的例子：

```c
void (*signal(int, void (*)(int)))(int);
```

上面声明了一个函数，返回值为 `void (*)(int)` ，函数名为 `signal`，参数为`int, void (*)(int)`(一个整形参数，一个函数指针参数)。此声明还可写成这样：

```c
typedef void (*HANDLER)(int);
HANDLER signal(int, HANDLER);
```

HANDLER为一个函数指针变量，类型为：`void (*)(int)`

其实这里讲了同样一个东西，`void (*something)(int);`，当`something`是一个变量的时候，那么我们说它的类型是一个函数指针（返回值为void，参数为int）；如果`something`是一个函数，那么我们说它的返回值是一个函数指针（返回值为void，参数为int）。实际上你应该发现了，无论是变量还是函数，当我们使用`something`时，我们最终都是得到一个值（变量的话我们去相应的内存直接取，函数的话我们去相应的内存得到函数入口，最后得到一个返回值），而这个值的类型是一个函数指针（返回值为void，参数为int）。

在学这章之前，我一直以为类型声明是直接的 `type variable;`，但学了这个之后我才发现，也可以通过 variable的所处的位置得知它的类型。如果你看`typedef void (* variable)(int);`觉得很自然，那么就学到位了。

### 运算符优先级

例子：

```c
if(flags & FLAG != 0)
//与
if(flags & (FLAG != 0))
//是一样的
```

```c
r = hi<<4 + low;
//和
r = hi<< (4+low);
//是一样的
```

用加括号的方法可以完全避免优先级的问题，但表达式中有太多的括号反而不容易理解。因此，记住C语言的运算符优先级是有益的。遗憾的是，运算符优先级有15个之多，记住它们并不是件容易的事。

![C语言优先级](https://wx2.sinaimg.cn/mw690/006zFO3ggy1fd8rnxlhqjj30we0pejut.jpg)

如果你实在记不住，加括号吧。

### 注意作为语句结束标志的分号

这条不都说了，新手常犯错误：

```c
for(int i=0;i<len;i++);
  a[i] = i;
```

在`if()`和`for()`等条件或者循环语句后加个分号，然后花上一天时间去锻炼你的找不同能力吧，哈哈。

### switch语句

C语言和Pascal语言不一样，请看下面例子：

```c
switch(color){
  case 1: printf("red");
    break;
  case 2: printf("yellow");
    break;
  case 3: printf("blue");
    break;
}
```

```Pascal
case color of
1:  write('red');
2:  write('yellow');
3:  write('blue');
end
```

C语言把case标号当做真正的标号，因此程序的控制流程会径直通过case标号，而不会受到任何影响。而另一方面，在Pascal语言中每个case标号都隐含的结束了前一个case部分。新手很容易遗忘`break语句`，但我们也可以利用这种灵活性，看例子：

```c
case SUBSTRACT:
  opnd2 = -opnd2;
  /*此处没有break语句*/
case ADD:
  ···
```

```c
case '\n':
  linecount++;
  /*此处没有break语句*/
case '\t':
case ' ':
```

### “悬挂”else引发的问题

这个问题已经熟为人知，而且也并非C语言所独有。

考虑下面的程序片段：

```c
if(x == 0)
  if(y==0)  error();
else{
  z= x+y;
  f(&z);
}
```

这段代码的逻辑其实是这样：

```c
if(x==0){
  if(y==0)
    error();
  else{
    z=x+y;
    f(&z);
  }
}
```

![带收尾界定符的](https://wx3.sinaimg.cn/mw690/006zFO3ggy1fd8vim3axgj30z80xadk7.jpg)

![](https://wx4.sinaimg.cn/mw690/006zFO3ggy1fd8vplxgdgj30pc06cwff.jpg)

初始化列表的每一行都是以逗号结尾的， 正因为每一行在语法上的这种相似性，自动化的程序设计工具 （例如，代码编辑器等）才能够更方便地处理很大的初始化列表。例如：

```c
int days[] = {1,2,3,};
int days1[] = {
    1,
    2,
    3,
};
int a[2][3]={
    {1,2,3},
    {4,5,6},
};
char b[3][10]={
    "one"  ,
    "two"  ,
    "three",
};
```

这个问题我在刷leetcode的时候自己构建测试数据集的时候碰到过，语法的相似性确实会方便不少（我当时就花了点精力在考虑最后这个缺失的逗号上）。

![](https://wx2.sinaimg.cn/mw690/006zFO3ggy1fd8vuhb2ysj30xg06k76e.jpg)

python就是用缩进来处理语句的啊。swift都抛弃分号啦。

## 语义“陷阱”

### 指针与数组

1. 不是指向下一个内存，而是下一个数组元素的地址

```
int d[3]={1,2,3};
int n = d+1;
printf("%d",d);
printf("%d",n);
```

2. 实际上a[i]是*(a+i)的简写形式，所以你用i[a]，也可以，不过绝不推荐这样写。

3. 二维数组实际上是由数组指针来实现的。

### 字符串指针

1. 字符串以'\0'结尾，strlen()不把'\0'计算在内。
2. 变量离开作用域自动释放内存，malloc()显示分配内存需要程序员自己释放：free()（否则只能等到程序运行结束由系统释放）。

合并两个字符串的例子：

```c
char *r, *malloc();
r = malloc(strlen(s)+strlen(t)+1);
//如果分配内存失败，malloc返回空指针NULL，NULL在内存中为全0
if(!r){
  complain();
  exit(-1);
}
strcpy(r,s);
strcat(r,t);
```

### 作为参数的数组声明

C语言中，我们没有办法可以将一个数组作为函数参数直接传递。如果我们将数组名作为参数，那么数组名会立刻被转换指向该数组第一个元素的指针。

c语言会自动将作为参数的数组声明转化为相应的指针声明。

```c
char hello[] = "hello";
//下面两个等价
printf("%s\n",hello);
printf("%s\n",&hello[0]);
//下面两个函数等价
int strlen(char s[]){

}
int strlen(char *s){

}

main(int argc, char* argv[]){

}

main(int argc, char** argv){
  
}
```
