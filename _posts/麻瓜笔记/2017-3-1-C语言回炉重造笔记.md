---
layout: post
title: C语言回炉重造笔记
categories: 麻瓜笔记
tags: [C语言, 教程, 编程语言]
comments: true
---

# C缺陷与陷阱

## 词法“陷阱”

### `=` 不同于 `==`

为什么赋值使用`=`，比较使用`==`呢？

由Algol派生而来的大多数程序设计语言，例如 Pascal 和 Ada，使用符号 `:=` 作为赋值运算符，符号 `=` 作为比较运算符。而C语言使用另一种表示法，符号 `=` 作为赋值运算符，符号 `==` 作为比较运算符。**一般而言赋值运算相对于比较运算出现得更频繁，因为字符较少的 `=` 就被赋予了更常用的含义--赋值操作。** 此外，**在C语言中赋值符号被作为一种操作符对待**，因而重复进行赋值操作（a=b=c）可以很容易地书写，并且赋值操作还可以被嵌入到更大的表达式当中去。

由此产生一个问题，**很多新手容易将比较运算符 `==` 错写成赋值运算符 `=`**。

看例子：

```c
while(c = ' ' || c == '\t' || c == '\n')
  c = getc(f);
```

由于程序员在比较 `' '` 和 c 时，误将比较运算符 `==` 写成了 赋值运算符 `=` 。 因为赋值运算符 `=` 的优先级要低于逻辑运算符 `||` ，因此实际上是以下表达式 `' ' || c == '\t' || c == '\n'` 赋给了 c 。因为 `' '`不等于0（`' '`的ASCII码值为32），**那么无论变量c此前为何值，上述表达式求值的结果都是1**，因此循环将一直进行下去直到整个文件结束。文件结束之后循环是否还会进行下去，这取决于 `getc` 库函数的具体实现，在文件指针达到文件结尾之后是否还允许继续读取字符。如果允许继续读取字符，那么循环将一直进行下去，从而成为一个死循环。

### 词法分析中的贪心法

一些 C 记号，如 `/、*和=` 只有一个字符。而其他一些 C 记号，如 `/*和==` ，以及标识符，具有多个字符。当 C 编译器遇到紧连在一起的/和*时，它必须能够决定是将这两个字符识别为两个分离的记号还是一个单独的记号。C语言对这个问题的解决方案可以归结为一个很简单的规则：每个符号应该包含尽可能多的字符。这个策略被称为 **贪心法**。

看例子：

表达式

```c
a --- b
```

与表达式

```c
a -- - b
```

的含义相同，而与

```c
a - -- b
```

的含义不同。

### 整形常量与进制

如果整形常量的第一个字符是数字0，那么该常量将被视作八进制数，因此，10与010的含义截然不同。0x代表16进制。

### 强制类型转换

```c
int i;
i = 19.5;
printf("%d",i);
i = 19.6;
printf("%d",i);
```

结果都是19。可见这里并没有四舍五入，而是直接截取整数部分。

### C语言没有bool

在C语言标准(C89)没有定义布尔类型，所以C语言判断真假时以0为假，非0为真。

条件运算符是唯一一个有3个操作数的运算符，所以有时又称三元运算符。

```c
int i,a,b;
i = 19;
a = -20;
b = (a+i)?a:i;
printf("%d\n", b);
```

结果是-20。你可以看到由于C语言没有bool类型，所以只能直接对整形的数进行判断了，只要不是0，就是真，负数也是真。

```c
#include <stdio.h>
int main()
{
    int i,a,b;
    i = 19;
    a = -20;
    b = (a+i)?a:i;
    if(a+i){
        printf("%d\n", a+i);
    }
    return 0;
}
```

同样if也是这个道理，只要不是0，都为真。

```C
//定义一个int类型变量，当变量值为0时表示false，值为1时表示true
int flag;
flag = 0;
//......
flag = 1;

if( flag )
{
//......
}
```

但这种做法不直观，而且没有明确flag一定是布尔值。所以我们又借助C语言的宏定义：

```c
//宏定义布尔类型
#define BOOL int
#define TRUE 1
#define FALSE 0

//定义一个布尔变量
BOOL flag = FALSE;
```

这种方法虽然直观，但依然是换汤不换药，变量flag在编译器看来依然是int类型。

　　新版本总会改进一些不好的地方，所以在最新的C语言标准(C99)解决了布尔类型的问题。C99提供了_Bool 型，所以布尔类型可以声明为 _Bool flag。

　　_Bool依然仍是整数类型，但与一般整型不同的是，_Bool变量只能赋值为0或1，非0的值都会被存储为1。

　　C99还提供了一个头文件 <stdbool.h> 定义了bool代表_Bool，true代表1，false代表0。只要导入 stdbool.h ，就能非常方便的操作布尔类型了。

```c
//导入 stdbool.h 来使用布尔类型
#include <stdbool.h>
#include <stdio.h>

//计算n!,n的值在main中定义
int main(void)
{
    int n = 10;    //计算叠乘数
    int sum = 1; //用来存放叠乘的结果
    bool flag = false;    //叠乘标记

    int num = n;    //循环次数
    while( !flag )
    {
        sum = sum * (num--);
        //当num=1时结束循环
        if( num == 1)
        {
            flag = true;
        }
    }
    printf ("%d的叠乘值为 %d \n", n, sum);
    return 0;
}
```

### 字符与字符串

C语言单引号和双引号含义迥异，在某些情况下把两者弄混，编译器并不会检测报错，从而在运行时产生难以预料的效果。

用单引号引起的一个字符实际上代表一个整数，整数值对应于该字符在编译器采用的字符集中的序列值，因此，对于采用ASCII字符集的编译器而言，`'a'`的含义与`0141`(八进制)或者`97`(十进制)严格一致。

用双引号引起的字符串，代表的确是一个指向无名数组起始字符的指针，该数组被引号之间的字符以及一个额外的二进制为零的字符'\0'初始化。

下面的这个语句：

```c
printf("Hello world\n");
//与
char s[] = {'H','e','l','l','o',' ','w','o','r','l','d','\n',0};
printf("%s\n", s);
```

![C语言字符和字符串](https://wx4.sinaimg.cn/mw690/006zFO3ggy1fd4ss43xi0j31080j8n3x.jpg)

## 语法“陷阱”

### 理解函数声明

任何C语言变量的声明都由两部分组成：类型以及一组类似表达式的声明符（declarator）。

```
float f,g;
float ((f));
float ff();
float *pf;
float *g(),(*h)();
(float (*)())
```

搞懂上面的，然后来个组合重磅的：

```
(* (void (*)())0)();
```

`(void (*)())0`的意思是对0进行强制类型转换，类型是：`void (*)()`，而这是一个函数指针(该指针指向一个函数的入口)，该函数返回值是void。

外面是一个函数调用，`(*funcptr)();`

用typedef可以实现相同的效果：

```
typedef void (*funcptr)();
(* (funcptr)0)();
```

再看下面的例子：

```c
void (*signal(int, void (*)(int)))(int);
```

上面声明了一个函数，返回值为 `void (*)(int)` ，函数名为 `signal`，参数为`int, void (*)(int)`(一个整形参数，一个函数指针参数)。此声明还可写成这样：

```c
typedef void (*HANDLER)(int);
HANDLER signal(int, HANDLER);
```

HANDLER为一个函数指针变量，类型为：`void (*)(int)`

其实这里讲了同样一个东西，`void (*something)(int);`，当`something`是一个变量的时候，那么我们说它的类型是一个函数指针（返回值为void，参数为int）；如果`something`是一个函数，那么我们说它的返回值是一个函数指针（返回值为void，参数为int）。实际上你应该发现了，无论是变量还是函数，当我们使用`something`时，我们最终都是得到一个值（变量的话我们去相应的内存直接取，函数的话我们去相应的内存得到函数入口，最后得到一个返回值），而这个值的类型是一个函数指针（返回值为void，参数为int）。

在学这章之前，我一直以为类型声明是直接的 `type variable;`，但学了这个之后我才发现，也可以通过 variable的所处的位置得知它的类型。如果你看`typedef void (* variable)(int);`觉得很自然，那么就学到位了。

### 运算符优先级

例子：

```c
if(flags & FLAG != 0)
//与
if(flags & (FLAG != 0))
//是一样的
```

```c
r = hi<<4 + low;
//和
r = hi<< (4+low);
//是一样的
```

用加括号的方法可以完全避免优先级的问题，但表达式中有太多的括号反而不容易理解。因此，记住C语言的运算符优先级是有益的。遗憾的是，运算符优先级有15个之多，记住它们并不是件容易的事。

![C语言优先级](https://wx2.sinaimg.cn/mw690/006zFO3ggy1fd8rnxlhqjj30we0pejut.jpg)
